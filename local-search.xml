<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程的概念、组织、特征"><a href="#进程的概念、组织、特征" class="headerlink" title="进程的概念、组织、特征"></a>进程的概念、组织、特征</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-07-08.png"><br>在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程（Process）的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性）<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-15-40.png"></p><ul><li>注意：PCB是进程存在的唯一标志<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-16-05.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-33-07.png"><br>PCB是给操作系统用的<br>程序段、数据段是给进程自己用的</li><li>更准确来说 <strong>PCB、程序段、数据段</strong> 三部分组成了 <strong>进程实体（进程映像）</strong></li><li>程序是静态的 进程是动态的</li><li><strong>进程</strong>是<strong>进程实体</strong>的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位。</li></ul><h3 id="进程的状态与转化"><a href="#进程的状态与转化" class="headerlink" title="进程的状态与转化"></a>进程的状态与转化</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-21-42.png"></p><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-22-47.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-26-35.png"></p><ul><li>阻塞态 → 就绪态 不是进程自身能控制的 是一种<strong>被动行为</strong>，需要其他相关进程的协助</li><li>运行态 → 阻塞态 是一种进程自身做出的<strong>主观行为</strong></li><li>不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</li></ul><h3 id="进程的组织方式"><a href="#进程的组织方式" class="headerlink" title="进程的组织方式"></a>进程的组织方式</h3><ul><li>链接方式<ul><li>按照进程状态将PCB分成多个队列 <ul><li>例如单核CPU计算机的执行指针or多核CPU的执行队列、就绪队列、阻塞队列（很多操作系统还会根据阻塞原因不同，贼分为多个阻阻塞队列）</li></ul></li><li>操作系统持有指向各个队列的指针</li></ul></li><li>索引方式<ul><li>根据进程状态的不同，建立几张索引表<ul><li>与链接方式类似，但是队列换成了索引表</li></ul></li><li>操作系统持有指向各个索引表的指针</li></ul></li></ul><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、<strong>实现进程状态转换</strong>等功能<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-39-36.png"></p><ul><li>进程的控制是用<strong>原语</strong>实现的<ul><li><strong>原语</strong>是一种特殊的程序，它的执行具有<strong>原子性</strong>。也就是说，这段程序的运行必须一气呵成，不可中断。<ul><li><strong>原语属于操作系统内核,只有内核程序可直接调用”原语”</strong></li></ul></li><li>可以通过<code>关中断指令</code>和<code>开中断指令</code>这两个<strong>特权指令</strong>来实现<strong>原子性</strong></li></ul></li></ul><p><strong>进程控制相关的原语</strong><br>进程的创建<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-48-06.png"><br>进程的终止<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-48-16.png"><br>进程的阻塞和唤醒(<strong>阻塞和唤醒要成对出现</strong>)<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-49-27.png"><br>阻塞原语(Block) 唤醒原语(Wakeup) 必须成对使用如果在某进程中调用了Block原语，则必须在与之合作的或其他相关的进程中安排一条相应的Wakeup原语，以便唤醒阻塞进程；否则，阻塞进程将会因不能被唤醒而永久地处于阻塞状态。</p><p>进程的切换<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-50-15.png"></p><ul><li>进程的控制会导致进程状态的转化。无论哪个进程控制原语，要做的无非三类事情:<ol><li>更新PCB中的信息<ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复其运行环境</li></ul></li><li>将PCB插入合适的队列</li><li>分配&#x2F;回收资源</li></ol></li></ul><h3 id="进程的通信IPC"><a href="#进程的通信IPC" class="headerlink" title="进程的通信IPC"></a>进程的通信IPC</h3><p> 进程间通信（Inter-Process Communication， IPC）是指两个进程之间产生数据交互</p><p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程拥有的内存地址空间相互独立</strong>。<strong>为了保证安全</strong>，<strong>一个进程不能直接访问另一个进程的地址空间</strong>,因此进程通信需要操作系统的支持<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-19-54-07.png"></p><p>PV操作是低级通信方式,高级通信方式是指以较高的效率传输大量的通信方式 高级通信方式主要有以下三类:</p><h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写&#x2F;读操作实现进程之间的信息交换<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-29-20-00-12.png"><br>为避免出错，各个进程对共享空间的访问应该是互斥的。各个进程可使用操作系统内核提供的同步互斥工具（如P、V操作）<br>共享存储又分两种:</p><ul><li>基于数据结构的共享(低级方式)<ul><li>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</li></ul></li><li>基于存储区的共享(高级方式)<ul><li>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统,操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具。这种共享方式速度很快，是一种高级通信方式。</li></ul></li></ul><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>进程间的数据交换以<strong>格式化的消息（Message）为单位</strong>。进程<strong>通过操作系统提供的“发送消息&#x2F;接收消息”两个原语</strong>进行数据交换。</p><ol><li><p>直接通信方式<br>发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息</p></li><li><p>间接通信方式<br>发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。 这种中间实体一般称为信箱。该通信方式广泛应用于计算机网络中</p></li></ol><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-20-36-47.png"><br>一个管道：半双工通信（单向，可←可→）   两个管道才能实现双向同时通信<br>写进程往管道写数据，即使管道没被写满，只要管道没空，读进程就可以从管道读数据<br>读进程从管道读数据。即使管道没被读空，只要管道没满，写进程就可以往管道写数据</p><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-20-44-37.png"></p><p>可以把线程理解为“轻量级进程”。<strong>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</strong><br>引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可以并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）<br>引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）。<strong>线程则作为处理机的分配单元。</strong><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-20-44-55.png"><br>与进程类似，系统也为每个线程配置一个线程控制块TCB,用于记录控制和管理线程的信息。<br>线程控制块通常包括：</p><ol><li>线程标识符；</li><li>一组寄存器，包括程序计数器、状态寄存器和通用寄存器；</li><li>线程运行状态，用于描述线程正处于何种状态；</li><li>优先级；</li><li>线程专有存储区，线程切换时用于保存现场等；</li><li>堆栈指针，用于过程调用时保存局部变量及返回地址等。</li></ol><p>同一进程中的所有线程都完全共享进程的地址空间和全局变量。各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。</p><ul><li>在同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。（引入线程后，处理机还是有可能在进程间切换）</li><li>线程可以单独执行程序</li></ul><h3 id="线程的实现方式和多线程模型"><a href="#线程的实现方式和多线程模型" class="headerlink" title="线程的实现方式和多线程模型"></a>线程的实现方式和多线程模型</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-20-48-31.png"><br><strong>线程的实现方式</strong></p><ul><li>用户级线程ULT<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-20-55-11.png"><br>CPU的调度单位仍为进程</li><li>内核级线程KLT<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-20-56-59.png"></li><li>组合方式<br>上述两种方式的结合</li></ul><p><strong>多线程模型</strong><br>有些系统同时支持用户线程和内核线程，由于用户级线程和内核级线程连接方式的不同，从而形成了下面三种不同的多线程模型。</p><ol><li>一对一模型<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-21-02-09.png"></li><li>多对一模型<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-21-02-21.png"></li><li>多对多模型<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-21-03-21.png"></li></ol><h3 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-21-04-50.png"></p><h3 id="线程的组织与控制"><a href="#线程的组织与控制" class="headerlink" title="线程的组织与控制"></a>线程的组织与控制</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-21-05-30.png"></p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-06-17.png"><br>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题<br>调度的三个层次</p><ol><li>高级调度<br>高级调度（作业调度）。按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。</li><li>低级调度<br>低级调度（进程调度&#x2F;处理机调度）—— 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。<br>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</li><li>中级调度<br>中级调度（内存调度）——按照某种策略决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。<br>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。<br>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-12-42.png"><br>三层调度的联系与对比<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-08-46.png"></li></ol><h3 id="进程调度的时机、切换与过程、方式"><a href="#进程调度的时机、切换与过程、方式" class="headerlink" title="进程调度的时机、切换与过程、方式"></a>进程调度的时机、切换与过程、方式</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-14-51.png"></p><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h4><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p><ul><li><strong>需要进行</strong>进程调度与切换的情况<ul><li>当前运行的进程<strong>主动放弃</strong>处理机<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞（如 等待I&#x2F;O）</li></ul></li><li>当前运行的进程<strong>被动放弃</strong>处理机<ul><li>分给进程的时间片用完</li><li>有更紧急的事要处理（如 I&#x2F;O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul></li><li><strong>不能进行</strong>进程调度与切换的情况<ul><li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在<strong>操作系统内核程序临界</strong>区中（但是进程在普通临界区中是可以进行调度、切换的。）</li><li>在<strong>原子操作过程中（原语）</strong>。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li></ul></li></ul><p>注意：</p><ul><li>进程在操作系统内核程序临界区中不能进行调度与切换  <ul><li>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列</li></ul></li><li>进程在操作系统普通临界区中不能进行调度与切换</li></ul><h4 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h4><p><code>狭义的进程调度</code>与<code>进程切换</code>的区别：<br><strong>狭义的进程调度</strong>指的是从就绪队列中<strong>选中一个要运行的进程</strong>。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）<br><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程。  </p><p><strong>广义的进程</strong>调度包含了选择一个进程和进程切换两个步骤。  </p><p>进程切换的过程主要完成了：</p><ol><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复<br>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li></ol><p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行进程<strong>调度、切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h4 id="进程调度的方法"><a href="#进程调度的方法" class="headerlink" title="进程调度的方法"></a>进程调度的方法</h4><ol><li>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。<ul><li>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li></ul></li><li>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。<ul><li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</li></ul></li></ol><h3 id="调度器、闲逛进程"><a href="#调度器、闲逛进程" class="headerlink" title="调度器、闲逛进程"></a>调度器、闲逛进程</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-31-17.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-31-47.png"><br>闲逛进程：<br>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）<br>闲逛进程的特性：</p><ul><li>优先级最低</li><li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li><li>能耗低</li></ul><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-34-12.png"></p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-51-01.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-50-46.png"></p><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 FCFS"></a>先来先服务 FCFS</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-39-00.png"></p><h4 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先 SJF"></a>短作业优先 SJF</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-39-34.png"><br>注意：</p><ol><li>做题时，若题目中未特别说明，所提到的“短作业&#x2F;进程优先算法”默认是非抢占式的</li><li>“SJF 调度算法的平均等待时间、平均周转时间最少” 的说法<strong>不正确 不够严谨</strong><br> 应该说 “<strong>在所有进程都几乎同时到达时</strong>，采用SJF调度算法的平均等待时间、平均周转时间最少”<br> 如果不加上前提条件  那么应该说 “抢占式的短作业&#x2F;进程优先调度算法（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”</li><li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</li></ol><h4 id="高响应比优先-HRRN"><a href="#高响应比优先-HRRN" class="headerlink" title="高响应比优先 HRRN"></a>高响应比优先 HRRN</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-43-53.png"></p><h4 id="时间片轮转调度算法-RR"><a href="#时间片轮转调度算法-RR" class="headerlink" title="时间片轮转调度算法 RR"></a>时间片轮转调度算法 RR</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-46-22.png"></p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-47-05.png"></p><h4 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-49-43.png"></p><h4 id="多级反馈队列调度算法（融合了前几种算法）"><a href="#多级反馈队列调度算法（融合了前几种算法）" class="headerlink" title="多级反馈队列调度算法（融合了前几种算法）"></a>多级反馈队列调度算法（融合了前几种算法）</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-47-32.png"></p><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="进程同步、进程互斥"><a href="#进程同步、进程互斥" class="headerlink" title="进程同步、进程互斥"></a>进程同步、进程互斥</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-49-59.png"></p><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。<br>操作系统要提供<strong>进程同步机制</strong>来解决异步问题，让本来异步并发的进程互相配合，有序推进</p><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-22-58-23.png"><br>注意：</p><ul><li><strong>临界区</strong>时进程中<strong>访问临界资源的代码段</strong>（临界区也可称为<strong>临界段</strong>）</li><li><strong>进入区</strong>和<strong>退出区</strong>时<strong>负责实现互斥的代码段</strong></li></ul><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ol><h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h3><p>知识点：<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-01-10.png"></p><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-05-28.png"><br>只能按 P0 P1 P0 P1……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。因此，单标志法存在的主要问题是：违背“空闲让进”原则。</p><ul><li>检查-&gt;临界区-&gt;谦让(给自己上锁,给对方解锁)</li></ul><h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-04-25.png"></p><ul><li>检查-&gt;表达意愿(给对方上锁)-&gt;临界区-&gt;解锁</li></ul><h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-06-37.png"></p><ul><li>表达意愿(上锁)-&gt;检查-&gt;临界区-&gt;解锁</li></ul><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-07-22.png"></p><ul><li>表达意愿-&gt;谦让-&gt;检查(对方是否表达意愿,自己是否谦让)-&gt;进入临界区-&gt;解锁</li></ul><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h3><p>知识点:<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-14-28.png"></p><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h4><p>利用“开&#x2F;关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p><ul><li>关中断后即不允许当前进程被中断，也必然不会发生进程切换</li><li>直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区<br>优点：简单、高效<br>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</li></ul><h4 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-16-59.png"></p><h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-17-16.png"></p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>解决临界区最简单的工具就是互斥锁(mutex lock)。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release。释放锁。<br>每个互斥锁有一个布尔变量available,表示锁是否可用。如果锁是可用的，调用acquire。会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire()&#123;<br>    <span class="hljs-keyword">while</span>(!available)<br>        ;                   <span class="hljs-comment">//忙等待</span><br>    available=<span class="hljs-literal">false</span>;        <span class="hljs-comment">//获得锁</span><br>&#125;<br>release()&#123;<br>    available=<span class="hljs-literal">true</span>;         <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>acquire()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。<br>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire。。当多个进程共享同一个CPU时，就浪费了 CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p><p>特性：</p><ul><li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li><li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li><li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li><li>不太适用于单处理机系统，忙等的过程中不可能解锁</li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>知识点:<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-21-19.png"><br>前面所学的进程互斥的四种软件 三种硬件实现方法 都无法实现”让权等待” 引出了 信号量机制（记录型信号量解决了让权等待）  </p><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。 </p><p><strong>信号量</strong>其实就是一个变量 （可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。</p><p><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。原语是由<strong>关中断&#x2F;开中断指令</strong>实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p><ul><li><strong>原语属于操作系统内核,只有内核程序可直接调用”原语”</strong></li></ul><p><strong>一对原语</strong>：<strong>wait(S)</strong> 原语和 <strong>signal(S)</strong> 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的<strong>信号量 S</strong> 其实就是函数调用时传入的一个参数。</p><p>wait、signal 原语常<strong>简称为 P、V操作</strong>（来自荷兰语 proberen 和 verhogen）。因此，做题的时候常把wait(S)、signal(S) 两个操作分别写为 <strong>P(S)、V(S)</strong></p><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-28-25.png"></p><ul><li>当信号量大于0，其表示可用资源数目<br>当信号量小于0，其绝对值为因请求该资源而被阻塞的进程数目，即等待进入临界区的进程数目<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-29-01.png"></li><li>记录型信号量解决了让权等待</li></ul><h3 id="用信号量实现进程互斥、同步、前驱关系"><a href="#用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量实现进程互斥、同步、前驱关系"></a>用信号量实现进程互斥、同步、前驱关系</h3><p>知识点：<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-30-18.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-31-29.png"><br>进程同步问题：让本来异步并发的进程互相配合，有序推进。<br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-32-08.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-32-29.png"></p><p>一般：互斥问题 信号量初值设为1 （读-写） 同步问题 信号量初值设为0 （生-消）</p><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-38-58.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-41-23.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-41-43.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-41-59.png"></p><h3 id="多生产者-消费者问题"><a href="#多生产者-消费者问题" class="headerlink" title="多生产者-消费者问题"></a>多生产者-消费者问题</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-44-11.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-45-10.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-45-44.png"></p><ul><li>即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象<ul><li>原因在于：原因在于:本题中的缓冲区大小为1，在任何时刻，<strong>apple、 orange、plate三个同步信号量中最多只有一个是1</strong>。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区</li></ul></li><li>但如果缓冲区大小大于1，就必须专门设置一个互斥信号量 mutex 来保证互斥访问缓冲区。</li></ul><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-48-05.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-48-42.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-49-00.png"></p><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-49-26.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-49-43.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-50-14.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-50-38.png"></p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-50-58.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-51-30.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-51-37.png"></p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-52-02.png"><br>管程是一种特殊的软件模块，有这些部分组成：</p><ol><li>局部于管程的<strong>共享数据结构</strong>说明</li><li>对该数据结构进行操作的<strong>一组过程</strong> （过程其实就是函数）</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ol><p>管程的基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li>每次仅允许一个进程在管程内执行某个内部过程。</li></ol><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-53-22.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-30-23-53-36.png"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-31-11-14-05.png"><br>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。</p><h4 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h4><ul><li>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</li><li>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的。</li></ul><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-31-11-16-41.png"></p><h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><p>产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ol><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ol><ul><li><p>注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p></li><li><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</p></li></ul><h4 id="什么时候会发生死锁"><a href="#什么时候会发生死锁" class="headerlink" title="什么时候会发生死锁"></a>什么时候会发生死锁</h4><ol><li>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资<br>源（CPU）的竞争是不会引起死锁的。</li><li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、<br>P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，<br>两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li><li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的<br>P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资<br>源）</li></ol><p>总之，对不可剥夺资源的不合理分配，可能导致死锁</p><h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-31-11-33-06.png"></p><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁。  </p><p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: <strong>SPOOLing技术</strong>。  </p><p>操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备  </p><p>使用了SPOOLing技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理了，不需要再阻塞等待  </p><p><strong>该策略的缺点</strong>：<br>并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件。</strong></p><h4 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h4><p><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。<br>破坏不剥夺条件：</p><ul><li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</li><li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li></ul><p><strong>该策略的缺点</strong>：</p><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><h4 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h4><p><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源</strong>，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。</p><p>可以<strong>采用静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p>该策略实现起来简单，但也有明显的<strong>缺点</strong>：<br>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，<strong>资源利用率极低</strong>。另外，该策略也有<strong>可能导致某些进程饥饿</strong>。</p><h4 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h4><p><strong>循环等待条件</strong>：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><p>可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定<strong>每个进程必须按编号递增的顺序请求资源</strong>，同类资源（即编号相同的资源）一次申请完。<br>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。<br>在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。因此，不可能出现所有进程都阻塞的死锁现象</p><p><strong>该策略的缺点</strong>：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号；</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol><h3 id="避免死锁（银行家算法）"><a href="#避免死锁（银行家算法）" class="headerlink" title="避免死锁（银行家算法）"></a>避免死锁（银行家算法）</h3><p>避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法所施加的限制条件较弱，可以获得较好的系统性能。</p><h4 id="安全序列、不安全状态、死锁的联系"><a href="#安全序列、不安全状态、死锁的联系" class="headerlink" title="安全序列、不安全状态、死锁的联系"></a>安全序列、不安全状态、死锁的联系</h4><p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。<br>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那<strong>系统也有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>如果系统处于<strong>安全状态</strong>，就<strong>一定不会发生死锁</strong>。如果系统进入<strong>不安全状态</strong>，就<strong>可能发生死锁</strong>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）<br>因此可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资源分配请求。这也是<strong>银行家算法</strong>的核心思想。</p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-31-14-42-48.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-31-14-42-59.png"></p><ul><li>银行家算法是事先预防策略，并没有真正分配资源</li></ul><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-31-14-44-31.png"><br>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：</p><ol><li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</li><li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li></ol><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-31-14-46-15.png"><br><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-31-14-46-44.png"></p><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p><img src="/2023/05/28/OS-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/2023-05-31-14-46-59.png"></p><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><ol><li>线程没有自己独立的地址空间，它共享其所属进程的空间<ul><li>进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。线程则作为处理机的分配单元。</li></ul></li><li>若两个线程属于同一个进程，由于线程之间共享地址空间，因此可直接通过共享的存储区进行通信；若两个线程不属于同一进程，由于不同进程地址空间独立，需要通过系统调用来实现通信</li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Servlet 基础</title>
    <link href="/2023/05/27/jsp-6/"/>
    <url>/2023/05/27/jsp-6/</url>
    
    <content type="html"><![CDATA[<p>有些Web应用可能只需要JSP+Javabean就能设计得很好，但是有些Web应用，就可能需要JSP+Javabean+servlet来完成，即需要服务器再创建一些servlet，配合JSP页面来完成整个Web应用程序的工作。关于这一点将在第7章的MVC模式中讲述。</p><h1 id="servlet的部署、创建与运行"><a href="#servlet的部署、创建与运行" class="headerlink" title="servlet的部署、创建与运行"></a>servlet的部署、创建与运行</h1><h2 id="源文件及字节码文件"><a href="#源文件及字节码文件" class="headerlink" title="源文件及字节码文件"></a>源文件及字节码文件</h2><h3 id="servlet类"><a href="#servlet类" class="headerlink" title="servlet类"></a>servlet类</h3><p>写一个创建servlet的类就是编写一个特殊类的子类，这个特殊的类就是javax.servlet.http包中的HttpServlet类。HttpServlet实现了Servlet接口，实现了响应用户的方法（这些方法将在后续内容中讲述）。HttpServlet的子类被习惯地称作一个Servlet类，这样的类创建的对象习惯地被称作一个servlet。</p><h3 id="字节码文件的保存"><a href="#字节码文件的保存" class="headerlink" title="字节码文件的保存"></a>字节码文件的保存</h3><p>字节码文件按着类的包名对应的目录路径保存到Web服务目录中特定子目录中。包名moon.sun对应的目录路径是moon\sun，因此，保存到：<br><code>\ch6\WEB-INF\classes\moon\sun</code><br>可以事先将Java源文件，按照其包名，比如，包名为moon.sun，保存到<br><code>\ch6\WEB-INF\classes\moon\sun</code><br>然后用命令行进入moon\sun的父目录classes（不要进入moon或sun目录）编译：<br><code>classes&gt; javac -cp servlet-api.jar moon\sun\Example6_1.java</code></p><h2 id="编写部署文件web-xml"><a href="#编写部署文件web-xml" class="headerlink" title="编写部署文件web.xml"></a>编写部署文件web.xml</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs web.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;<br>&lt;web-app&gt;<br>    &lt;servlet&gt;<br>        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;<br>        &lt;servlet-class&gt;moon.sun.Example6_1&lt;/servlet-class&gt;<br>    &lt;/servlet&gt;<br>    &lt;servlet-mapping&gt;<br>        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;<br>        &lt;url-pattern&gt;/lookHello&lt;/url-pattern&gt;<br>    &lt;/servlet-mapping&gt;<br>&lt;/web-app&gt;<br></code></pre></td></tr></table></figure><ul><li>Servlet类的字节码文件保存到指定的目录后，必须为Tomcat服务器编写一个部署文件，只有这样，Tomcat服务器才会用Servlet类创建servlet对象。</li><li>部署文件是一个XML文件，名字必须是web.xml。</li><li>web.xml由Tomcat服务器负责管理，Tomcat服务器配有内置的解析器，可以解析XML文件的标记中的数据。</li><li>编写的web.xml文件必须保存到Web服务目录的WEB-INF子目录中，比如ch6\WEB-INF中（不要保存在ch6中）。根据例子6_1给出的Servlet类，web.xml文件的内容如下（需要用纯文本编辑器编辑web.xml）</li><li>Web服务目录的WEB-INF子目录下的web.xml文件负责管理当前Web服务目录下的全部servlet，当该Web服务目录需要提供更多的servlet时，只要在web.xml文件中增加servlet和servlet-mapping子标记即可。</li><li>对于webapps下的Web服务目录，如果修改并重新保存web.xml文件，Tomcat服务器就会立刻重新读取web.xml文件，因此，修改web.xml文件不必重新启动Tomcat服务器。但是，如果修改导致web.xml文件出现错误，Tomcat服务器就会关闭当前Web服务目录下的所有servlet的使用权限。所以必须保证web.xml文件正确无误，才能成功启动Tomcat服务器。但是，对于不是webapps下的Web服务目录，如果新建或修改了相应的web.xml文件，需要重新启动Tomcat服务器。</li></ul><h2 id="servlet的创建与运行"><a href="#servlet的创建与运行" class="headerlink" title="servlet的创建与运行"></a>servlet的创建与运行</h2><ul><li><p>用户就可以根据web.xml部署文件来请求Tomcat服务器创建并运行一个servlet。</p></li><li><p>如果Tomcat服务器没有名字为hello的servlet，就会根据web.xml文件中servlet标记的子标记servlet-class指定的Servlet类创建一个名字为hello的servlet。因此，如果名字是hello的servlet被创建之后，又修改Java源文件、编译得到新的Servlet类，并希望Tomcat服务器用新的Servlet类创建servlet，那么就要重新启动Tomcat服务器。</p></li><li><p>请求Tomcat服务器运行名字是hello的servlet。</p></li></ul><h2 id="向servlet传递参数的值"><a href="#向servlet传递参数的值" class="headerlink" title="向servlet传递参数的值"></a>向servlet传递参数的值</h2><p>在请求一个servlet时，可以在请求的url-pattern中额外加入参数及其值，格式是：<br><code>url-pattern?参数1=值&amp;参数2=值…参数n=值</code><br>那么被请求的servlet就可以使用request对象获取参数的值，例如：<br><code>request.getParameter(参数n)</code></p><h1 id="servlet的工作原理"><a href="#servlet的工作原理" class="headerlink" title="servlet的工作原理"></a>servlet的工作原理</h1><p>servlet由Tomcat服务器负责管理，Tomcat服务器通过读取web.xml，然后创建并运行servlet。</p><h2 id="servlet-对象的生命周期"><a href="#servlet-对象的生命周期" class="headerlink" title="servlet 对象的生命周期"></a>servlet 对象的生命周期</h2><p>servlet由Tomcat服务器负责创建并完成初始化工作。当多个用户请求一个servlet时，服务器为每个用户启动一个线程。<br>一个servlet的生命周期主要有下列三个过程组成：</p><ol><li>servlet第一次被请求加载时，服务器创建servlet，servlet调用init方法完成必要的初始化工作。</li><li>新诞生的servlet再调用service方法响应用户的请求。</li><li>当服务器关闭时，调用destroy方法销毁servlet。</li></ol><ul><li><strong>init方法只被调用一次。</strong>当后续的用户请求servlet服务时，Tomcat服务器将启动一个新的线程，在该线程中，servlet调用service方法。也就是说，<strong>每个用户的每次请求都导致service方法被调用执行，其执行过程分别运行在不同的线程中。</strong></li></ul><h2 id="init方法"><a href="#init方法" class="headerlink" title="init方法"></a>init方法</h2><p><code>public void init(ServletConfig  config) throws ServletException</code><br>servlet第一次被请求加载时，服务器创建一个servlet，这个对象调用init方法完成必要的初始化工作。该方法在执行时，服务器会把一个SevletConfig类型的对象传递给init()方法，这个对象就被保存在servlet中，直到servlet被销毁。</p><h2 id="service方法"><a href="#service方法" class="headerlink" title="service方法"></a>service方法</h2><p><code>public void service(HttpServletRequest request  HttpServletResponse  response)throw ServletException,IOException</code><br>Tomcat服务器将两个参数传递给该方法。和init方法不同的是，<strong>init方法只被调用一次，而service方法可能被多次的调用。</strong>当后续的用户请求该servlet时，Tomcat服务器将启动一个新的线程，在该线程中servlet调用service方法响应用户的请求，调用过程运行在不同的线程中，互不干扰。因此，不同线程的service方法中的局部变量互不干扰，一个线程改变了自己的service方法中局部变量的值不会影响其他线程的service方法中的局部变量。</p><h2 id="destory方法"><a href="#destory方法" class="headerlink" title="destory方法"></a>destory方法</h2><p><code>public destroy()</code><br>当Tomcat服务器终止服务时，destroy()方法会被执行，销毁servlet.子类可直接继承这个方法，一般不需要重写。</p><h1 id="通过jsp页面访问servlet"><a href="#通过jsp页面访问servlet" class="headerlink" title="通过jsp页面访问servlet"></a>通过jsp页面访问servlet</h1><p>按着部署文件web.xml给出的servlet的url-pattern，用户除了可以在浏览器输入url-pattern请求运行一个servlet外，也可以通过JSP页面来请求一个servlet。<br>需要特别注意的是，如果web.xml文件中给出的servlet的url-pattern是&#x2F;lookHello，那么JSP页面请求servlet时，必须要写成 lookHello，不可以写成&#x2F;lookHello。</p><h2 id="通过表单向servlet提交数据"><a href="#通过表单向servlet提交数据" class="headerlink" title="通过表单向servlet提交数据"></a>通过表单向servlet提交数据</h2><p>如果web.xml文件中给出的servlet的url-pattern是&#x2F;computeBill，那么form表单中action给出的值就是computeBill ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>  <span class="hljs-attr">action</span>= <span class="hljs-string">&quot;computeBill &quot;</span>  &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当请求一个servlet时，也可以在请求的url-pattern中额外加入参数及其值，格式是：<br><code>url-pattern?参数1=值&amp;参数2=值…参数n=值</code><br>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>  <span class="hljs-attr">action</span>= <span class="hljs-string">&quot;computeBill?sideA=10.66&amp;sideB=23.9&amp;sideC=897 &quot;</span>  &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="通过超链接访问servlet"><a href="#通过超链接访问servlet" class="headerlink" title="通过超链接访问servlet"></a>通过超链接访问servlet</h2><p>JSP页面可以使用超链接去请求某个servlet。如果web.xml文件中给出的请求servlet的url-pattern是&#x2F;circle，那么超链接标记中href的值是circle（不要写成&#x2F;circle）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs web.xml">&lt;a href=&quot;circle&quot;&gt;&lt;/a&gt;<br></code></pre></td></tr></table></figure><h1 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h1><ul><li>Servlet类是HttpServlet的一个子类，在编写子类时就可以声明某些成员变量，那么，请求<strong>servlet的用户将共享该servlet的成员变量</strong>。</li><li>service方法可能被多次的调用。也就是说，当后续的用户请求该servlet时，Tomcat服务器将启动一个新的线程，在该线程中servlet调用service方法响应用户的请求，即每个用户的请求都导致service方法被调用执行，调用过程运行在不同的线程中，互不干扰。因此，<strong>不同线程的service方法中的局部变量互不干扰，一个线程改变了自己的service方法中局部变量的值不会影响其他线程的service方法中的局部变量。</strong></li></ul><h1 id="dopost和doget方法"><a href="#dopost和doget方法" class="headerlink" title="dopost和doget方法"></a>dopost和doget方法</h1><ul><li>HttpServlet类除了init、service、destroy方法外，该类还有两个很重要的方法：doGet和doPost，用来处理用户的请求并作出响应。</li><li>实际上HttpServlet类所给出的service方法的功能是检查HTTP请求类型（get、post），并在service方法中根据用户的请求方式，在service方法中对应地再调用doGet或doPost方法。</li><li>因此，<strong>在编写的Servlet类（HttpServlet类的一个子类）时，也可以不重写service方法来响应用户，直接继承service方法即可</strong>。</li><li><strong>如果不重写service方法，就需要在Servlet类中重写doPost或doGet方法来响应用户的请求</strong>。如果不论用户请求类型是post还是get，Tomcat服务器的处理过程完全相同，那么可以只在doPost方法中编写处理过程，而在doGet方法中再调用doPost方法即可，或只在doGet方法中编写处理过程，而在doPost方法中再调用doGet方法。如果根据请求的类型进行不同的处理，就要在两个方法中编写不同的处理过程（这一点比service方法更为灵活）</li></ul><h1 id="重定向与转发"><a href="#重定向与转发" class="headerlink" title="重定向与转发"></a>重定向与转发</h1><p>重定向的功能是将用户从当前页面或servlet定向到另一个JSP页面或servlet。转发的功能是将用户对当前JSP页面或servlet的请求转发给另一个JSP页面或servlet。本节学习在Servlet类中使用HttpServletResponse类的sendRedirect重定向方法，以及RequestDispatcher类的forward转发方法，并指出二者的区别。</p><h2 id="sendRedirect方法"><a href="#sendRedirect方法" class="headerlink" title="sendRedirect方法"></a>sendRedirect方法</h2><p>重定向方法<code>void sendRedirect(String location)</code><br>将用户重新定向到另一个JSP页面或servlet。重定向方法仅仅是将用户从当前页面或servlet定向到另一个JSP页面或servlet，但不能将用户对当前页面或servlet的请求（HttpServletRequest对象）转发给所定向的资源。即重定向的目标页面或servlet无法使用request获取用户提交的数据。</p><p>执行sendRedirect方法（重定向）时，Tomcat服务器还是要把当前的servlet代码执行完毕后才实施重定向（跳转）操作，但Tomcat服务器不再给用户看当前servlet代码的执行效果。如果在执行sendRedirect(URL url)方法后，servlet紧接着执行了return返回语句，那么Tomcat服务器会立刻结束当前servlet的执行。</p><h2 id="forward方法"><a href="#forward方法" class="headerlink" title="forward方法"></a>forward方法</h2><p>步骤1:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp"><span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">dispatcher</span> <span class="hljs-operator">=</span> <br>request.getRequestDispatcher(JSP页面的URL或servlet的url-pattern);<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp"><span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">dispatcher</span> <span class="hljs-operator">=</span> request.getRequestDispatcher(<span class="hljs-string">&quot;target.jsp&quot;</span>);<br></code></pre></td></tr></table></figure><p>步骤2:转发。<br>在步骤1中获取的<code>RequestDispatcher</code>对象调用</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp"><span class="hljs-keyword">void</span> <span class="hljs-title function_">forward</span><span class="hljs-params">(ServletRequest request,ServletResponse response)</span>             <span class="hljs-keyword">throws</span> <br>ServletException,ava.io.IOException<br></code></pre></td></tr></table></figure><p>方法可以将用户对当前JSP页面或servlet的请求转发给RequestDispatcher对象所指定的JSP页面或servlet，例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JSP">dispatcher.forward (request,response);<br></code></pre></td></tr></table></figure><p>把用户对当前JSP页面或servlet的请求转变为对转发到的JSP页面或servlet的请求。</p><p>RequestDispatcher对象可以把用户对当前JSP页面或servlet的请求转发给另一个JSP页面或servlet，而且将用户对当前JSP页面或servlet的请求传递给转发到的JSP页面或servlet。也就是说，当前页面<strong>所转发到的标页面或servlet可以使用request获取用户提交的数据</strong>。</p><h2 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h2><ul><li>转发（forwar）和重定向方法（sendRedirect）不同的是，用户可以看到转发到的JSP页面或servlet的运行效果，但是，在浏览器的地址栏中不能看到forward方法转发到的JSP页面的地址或servlet的地址，用户在浏览器的地址栏中所看到的仍然是当前JSP页面的URL或servlet的url-pattern。如果此时刷新浏览器，那么请求将是当前的JSP页面或servlet。<strong>所转发到的标页面或servlet可以使用request获取用户提交的数据。而重定向的目标页面或servlet无法使用request获取用户提交的数据</strong>。</li><li>另外，当servlet中执行forward方法实施转发操作时，Tomcat会立刻结速当前servlet的执行。而servlet中执行sendRedirect方法（重定向，也见4.2.3）时，Tomcat服务器还是要把当前的servlet代码执行完毕后才实施重定向（跳转）操作，但Tomcat服务器不再给用户看当前servlet代码的执行效果。如果在执行sendRedirect(URL url)方法后，servlet紧接着执行了return返回语句，那么Tomcat服务器会立刻结束当前servlet的执行。</li></ul><h1 id="使用session"><a href="#使用session" class="headerlink" title="使用session"></a>使用session</h1><p>HTTP通信协议是用户与服务器之间一种请求与响应（request&#x2F;response）的通信协议，属于无状态协议。所谓无状态是指，当用户（浏览器）发送请求给服务器，Tomcat服务器作出响应后，如果同一个用户再发送请求给Tomcat服务器时，Tomcat服务器并不知道就是刚才的那个用户。简单地说，Tomcat服务器不会记录用户的信息。<br>用户在访问一个Web服务目录期间，Tomcat服务器为该用户分配一个session对象（称为用户的会话），Tomcat服务器可以在各个页面以及servlet中使用这个session记录用户的有关信息，而且Tomcat服务器保证不同用户的session对象互不相同。有关session对象的原理、常用方法可参见第4章的4.3节</p><p>HttpServletRequest对象request调用getSession方法获取用户的session对象：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">HttpSession session=request.getSession(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>访问某个Web服务目录的用户，<strong>在不同的servlet中获取的session对象是完全相同的</strong>，不同的用户的session对象互不相同。</p>]]></content>
    
    
    <categories>
      
      <category>JSP</category>
      
      <category>第六章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSP 与Java bean</title>
    <link href="/2023/05/27/jsp-5/"/>
    <url>/2023/05/27/jsp-5/</url>
    
    <content type="html"><![CDATA[<p><font size=6><strong>目录</strong></font></p><ul><li><a href="#%E7%BC%96%E5%86%99javabean%E5%92%8C%E4%BD%BF%E7%94%A8jababean">编写javabean和使用jababean</a><ul><li><a href="#%E7%BC%96%E5%86%99javabean">编写javabean</a></li><li><a href="#%E4%BF%9D%E5%AD%98bean%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81">保存bean的字节码</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8bean">创建与使用bean</a><ul><li><a href="#%E4%BD%BF%E7%94%A8bean">使用bean</a></li><li><a href="#bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86">bean的加载原理</a></li><li><a href="#bean%E7%9A%84%E6%9C%89%E6%95%88%E8%8C%83%E5%9B%B4%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">bean的有效范围和生命周期</a></li></ul></li></ul></li><li><a href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BF%AE%E6%94%B9bean%E7%9A%84%E5%B1%9E%E6%80%A7">获取和修改bean的属性</a><ul><li><a href="#getproperty%E5%8A%A8%E4%BD%9C%E6%A0%87%E8%AE%B0">getproperty动作标记</a></li><li><a href="#setproperty%E5%8A%A8%E4%BD%9C%E6%A0%87%E8%AE%B0">setproperty动作标记</a></li></ul></li><li><a href="#bean%E7%9A%84%E8%BE%85%E5%8A%A9%E7%B1%BB">bean的辅助类</a></li><li><a href="#jsp%E4%B8%8Ebean%E7%BB%93%E5%90%88%E7%9A%84%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90">jsp与bean结合的简单例子</a></li></ul><h1 id="编写javabean和使用jababean"><a href="#编写javabean和使用jababean" class="headerlink" title="编写javabean和使用jababean"></a>编写javabean和使用jababean</h1><p>JSP页面可以将数据的处理过程指派给一个或几个bean来完成，即JSP页面调用这些bean完成数据的处理，并将有关处理结果存放到bean中，然后JSP页面负责显示bean中的数据。</p><h2 id="编写javabean"><a href="#编写javabean" class="headerlink" title="编写javabean"></a>编写javabean</h2><p>编写Javabean就是编写一个Java的类，所以只要会写类就能编写一个Javabean。这个类创建的一个对象称为一个Javabean，简称bean，分配给bean的变量（成员变量），也称bean的属性。为了能让使用bean的应用程序构建工具（比如Tomcat服务器）使用JSP动作标记知道bean的属性和方法，只须在类的方法命名上遵守以下规则：</p><ol><li>如果类的成员变量，也称bean的属性的名字是xxx，那么为了获取或更改bean的属性的值，类中必须提供两个方法：<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">getXxx()，用来获取属性xxx。<br>setXxx()，用来修改属性xxx.。<br></code></pre></td></tr></table></figure>也就是<strong>方法的名字用get或set为前缀，后缀是将属性（成员变量）名字的首字母大写的字符序列。</strong></li><li>类中定义的方法的访问权限都必须是public的。</li><li>类中定义的构造方法必须是public、无参数的。</li></ol><h2 id="保存bean的字节码"><a href="#保存bean的字节码" class="headerlink" title="保存bean的字节码"></a>保存bean的字节码</h2><p>例如：在webapps目录下新建一个Web服务目录ch5，创建bean的类的字节码文件需要按要求存放，因此需要在ch5下建立如下的目录结构（目录名字WEB-INF中的字母大写）：<br><code>\ch5\WEB-INF\classes</code></p><ul><li><code>ch5\WEB-INF\classes</code>目录下，根据包名对应的路径，在<code>classes</code>下再建立相应的子目录。比如，包名<code>tom.jiafei</code>对应的路径是<code>tom\jiafei</code>，那么在<code>classes</code>下建立子目录结构：<code>tom\jiafei</code>。</li><li>将创建bean的字节码文件，比如<code>Circle.class</code>，复制到<br><code>\WEB-INF\classes\tom\jiafei</code></li><li>为了调试程序方便，可以直接按照bean的包名将bean的源文件，比如<code>Circle.java</code>，保存在<code>\WEB-INF\classes\tom\jiafei</code>目录中，然后用命令行进入<code>tom\jiafei</code>的父目录<code>classes</code>（不要进入tom或jiafei目录）编译<code>Circle.java</code>：</li></ul><p><code>classes&gt;javac tom\jiafei\Circle.java</code></p><h2 id="创建与使用bean"><a href="#创建与使用bean" class="headerlink" title="创建与使用bean"></a>创建与使用bean</h2><h3 id="使用bean"><a href="#使用bean" class="headerlink" title="使用bean"></a>使用bean</h3><p>使用JSP动作标记useBean加载使用bean，语法格式是：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;bean的名字&quot;</span> class=<span class="hljs-string">&quot;创建bean的类&quot;</span> scope=<span class="hljs-string">&quot;bean有效范围&quot;</span>/&gt;<br>或<br>&lt;jsp:useBean id=<span class="hljs-string">&quot;bean的名字&quot;</span> class=<span class="hljs-string">&quot;创建bean的类&quot;</span> scope= <span class="hljs-string">&quot;bean有效范围&quot;</span>&gt;<br>&lt;/jsp:useBean&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;circle&quot;</span> class=<span class="hljs-string">&quot;tom.jiafei.Circle&quot;</span> scope=<span class="hljs-string">&quot;page&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>需要特别注意的是，其中的“创建bean的类”要带有包名，比如：<br><code>class=&quot;tom.jiafei.Circle&quot;</code></p><h3 id="bean的加载原理"><a href="#bean的加载原理" class="headerlink" title="bean的加载原理"></a>bean的加载原理</h3><p>Tomcat服务器首先在Tomcat服务器管理的pageContent内置对象中查找是否含有这样的bean。如果这样的bean存在，Tomcat服务器就分配这样的bean给用户，如果在pageContent中没有查找到JSP动作标记要求的bean，就根据class指定的类创建一个bean，并将所创建的bean添加到pageContent中。通过Tomcat服务器创建bean的过程可以看出，首次创建一个新的bean需要用相应类的字节码文件创建对象，当某些JSP页面再需要同样的bean时，Tomcat服务器直接将pageContent中已经有的bean分配给JSP页面，提高了JSP使用bean的效率。</p><ul><li>如果修改了字节码文件，必须重新启动Tomcat服务器才能使用新的字节码文件。</li></ul><h3 id="bean的有效范围和生命周期"><a href="#bean的有效范围和生命周期" class="headerlink" title="bean的有效范围和生命周期"></a>bean的有效范围和生命周期</h3><ol><li>page bean<br>scope取值为page的bean称为page bean.<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;circle&quot;</span> class=<span class="hljs-string">&quot;tom.jiafei.Circle&quot;</span> scope=<span class="hljs-string">&quot;page&quot;</span> /&gt;<br></code></pre></td></tr></table></figure></li></ol><ul><li>page bean的有效范围是用户访问的当前页面，存活时间直到当前页面执行完毕。</li><li>不同用户（浏览器）的page bean是互不相同的。也就是说，当两个用户同时访问一个JSP页面时，一个用户对自己page bean的属性的改变，不会影响到另一个用户。</li></ul><ol start="2"><li>session bean<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;circle&quot;</span> class=<span class="hljs-string">&quot;tom.jiafei.Circle&quot;</span> scope=<span class="hljs-string">&quot;session&quot;</span> /&gt;<br></code></pre></td></tr></table></figure></li></ol><ul><li>session bean的有效范围是用户访问的Web服务目录下的各个页面，存活时间是用户的会话期（session）间。</li><li>如果用户访问Web服务目录多个页面，那么每个页面id相同的session bean是同一个bean。</li><li>不同用户（浏览器）的session bean是互不相同的.</li><li>要使用session bean时，要保证用户端支持cookie</li></ul><ol start="3"><li>request bean<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;circle&quot;</span> class=<span class="hljs-string">&quot;tom.jiafei.Circle&quot;</span> scope=<span class="hljs-string">&quot;request&quot;</span> /&gt;<br></code></pre></td></tr></table></figure></li></ol><ul><li>bean的有效范围是用户请求的当前页面，存活时间是从用户的请求到请求结束。request bean存活时间略长于page bean的存活时间，原因是Tomcat服务器认为页面执行完毕后，响应才算结束。</li><li>不同用户的request bean的也是互不相同的。也就是说，当两个用户同时请求一个JSP页面时，一个用户对自己request bean的属性的改变，不会影响到另一个用户。</li></ul><ol start="4"><li>application bean<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;circle&quot;</span> class=<span class="hljs-string">&quot;tom.jiafei.Circle&quot;</span> scope=<span class="hljs-string">&quot;application&quot;</span> /&gt;<br></code></pre></td></tr></table></figure></li></ol><ul><li>application bean的有效范围是当前Web服务目录下的各个页面，存活时间直到Tomcat服务器关闭。</li><li>Tomcat服务器为访问Web服务目录的所有用户分配一个共享的bean，即不同用户的application bean也都是相同的一个。也就是说，任何一个用户对自己application bean的属性的改变，都会影响到其他的用户（不同Web服务目录的application bean互不相同）。</li></ul><p>综上 bean的有效范围见下图<br><img src="/2023/05/27/jsp-5/2023-05-27-22-42-37.png"></p><h1 id="获取和修改bean的属性"><a href="#获取和修改bean的属性" class="headerlink" title="获取和修改bean的属性"></a>获取和修改bean的属性</h1><p>使用useBean动作标记获得一个bean后，在Java程序片或表达式中bean就可以调用方法产生行为</p><h2 id="getproperty动作标记"><a href="#getproperty动作标记" class="headerlink" title="getproperty动作标记"></a>getproperty动作标记</h2><p>使用<code>getProperty动作标记</code>可以获得bean的属性值，并将这个值用串的形式发送给用户的浏览器。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:getProperty  name=<span class="hljs-string">&quot;bean的id &quot;</span> property=<span class="hljs-string">&quot;bean的属性&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:getProperty  name=<span class="hljs-string">&quot;bean的id &quot;</span>  property=<span class="hljs-string">&quot;bean的属性&quot;</span>&gt;<br>&lt;/jsp:getProperty&gt;<br></code></pre></td></tr></table></figure><p>其中，name取值是bean的id，用来指定要获取哪个bean的属性的值，property取值是该bean的一个属性的名字。<br>当JSP页面使用getProperty标记获取属性xxx的值时，必须保证bean有相应的getXxx方法，即对方法的名字的命名有特殊的要求。</p><ul><li>让request调用setCharacterEncoding方法设置编码为utf-8，以避免显示bean的属性值出现乱码现象</li></ul><h2 id="setproperty动作标记"><a href="#setproperty动作标记" class="headerlink" title="setproperty动作标记"></a>setproperty动作标记</h2><p>使用<code>setProperty动作标记</code>可以设置bean的属性值，使用这个标记之前，必须使用useBean标记得到一个相应的bean<br><code>setProperty动作标记</code>可以通过两种方式设置bean的属性值：</p><ol><li>将bean属性的值设置为一个表达式的值或字符序列。<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:setProperty name=<span class="hljs-string">&quot;bean的id &quot;</span> property=<span class="hljs-string">&quot;bean的属性&quot;</span> <br>value= <span class="hljs-string">&quot;&lt;%=expression%&gt;&quot;</span>/&gt;<br>&lt;jsp:setProperty name=<span class="hljs-string">&quot;bean的id &quot;</span> property=<span class="hljs-string">&quot;bean的属性&quot;</span> <br>value= <span class="hljs-string">&quot;字符序列&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>value给出的值的类型要和bean的属性的类型一致。</li><li>通过HTTP表单的参数的值来设置bean的相应属性的值。</li></ol><ul><li><p>用form表单的所有参数的值设置bean相对应的属性值的使用格式如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:setProperty  name= <span class="hljs-string">&quot;bean的id的名字&quot;</span>  property=<span class="hljs-string">&quot;*&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>在setProperty标记的上述用法中不具体指定bean属性的值将对应form表单中哪个参数指定的值，系统会自动根据名字进行匹配对应，但要求bean属性的名字必须在form表单中有名称相同的参数名字相对应，Tomcat服务器会自动将参数的字符串值转换为bean相对应的属性的值</p></li><li><p>用form表单的某个参数的值设置bean的某个属性值的使用格式如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:setProperty  name= <span class="hljs-string">&quot;bean的名字&quot;</span>  property=<span class="hljs-string">&quot;属性名&quot;</span>  param= <span class="hljs-string">&quot;参数名&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>setProperty标记的上述用法具体指定了bean属性的值将对应表单中哪个参数名（param）指定的值，这种设置bean的属性值的方法，不要求property给出的bean属性的名字和param给出的参数名一致，即不要求bean属性的名字必须和表单中某个参数。</p></li><li><p>注:用form表单设置bean的属性值时，只有提交了表单，对应的setProperty标记才会被执行。</p></li></ul><h1 id="bean的辅助类"><a href="#bean的辅助类" class="headerlink" title="bean的辅助类"></a>bean的辅助类</h1><p>写一个创建bean的类时，除了需要用import语句引入JDK提供的类，可能还需要自己编写一些其他的类，只要将这样类的包名和bean类的包名一致即可（也可以和创建bean的类写在一个Java源文件中）。</p><h1 id="jsp与bean结合的简单例子"><a href="#jsp与bean结合的简单例子" class="headerlink" title="jsp与bean结合的简单例子"></a>jsp与bean结合的简单例子</h1><p>JSP页面中调用bean可以将数据的处理从页面中分离出来，实现代码复用，以便更有效地维护一个Web应用。<br>如：创建bean的类的包名都是<code>red.star</code>，使用的Web服务目录仍然是<code>ch5</code>，因此，需要在<code>ch5</code>下建立如下的目录结构：<br><code>ch5\WEB-INF\classes\red\star</code><br>创建bean的字节码文件都需要保存在上述目录中。为了调试程序方便，可以直接按照创建bean的类的包名将相应的Java源文件保存在Web服务目录的相应目录中，比如将Java源文件保存在Web服务目录<code>ch5</code>的<code>WEB-INF\classes\red\star</code>目录中，然后使用<code>MS-DOS</code>命令行进入<code>\red\star</code>的父目录<code>classes</code>，如下编译Java源文件：<br><code>classes&gt; javac red\star\源文件名</code></p>]]></content>
    
    
    <categories>
      
      <category>JSP</category>
      
      <category>第五章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内置对象</title>
    <link href="/2023/05/27/jsp-4/"/>
    <url>/2023/05/27/jsp-4/</url>
    
    <content type="html"><![CDATA[<p><font size=6><strong>目录</strong></font></p><ul><li><a href="#request%E5%AF%B9%E8%B1%A1">request对象</a><ul><li><a href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E7%9A%84%E4%BF%A1%E6%81%AF">获取用户提交的信息</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%B1%89%E5%AD%97%E4%BF%A1%E6%81%AF">处理汉字信息</a></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%BE%E4%BE%8B">常用方法举例</a></li><li><a href="#%E5%A4%84%E7%90%86html%E6%A0%87%E8%AE%B0-%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99">处理html标记-不区分大小写</a><ul><li><a href="#form-%E6%A0%87%E8%AE%B0-form%E8%A1%A8%E5%8D%95">form 标记-form表单</a></li><li><a href="#input%E6%A0%87%E8%AE%B0">input标记</a></li><li><a href="#selectoption%E6%A0%87%E8%AE%B0-%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8%E6%88%96%E6%BB%9A%E5%8A%A8%E5%88%97%E8%A1%A8">select、option标记-下拉列表或滚动列表</a></li><li><a href="#textarea%E6%A0%87%E8%AE%B0">textarea标记</a></li><li><a href="#style%E6%A0%B7%E5%BC%8F%E6%A0%87%E8%AE%B0">style样式标记</a></li><li><a href="#table%E6%A0%87%E8%AE%B0-%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE-%E4%B8%8D%E8%83%BD%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE">table标记-主要用于显示数据 不能提交数据</a></li><li><a href="#%E6%A0%87%E8%AE%B0">标记</a></li><li><a href="#embed%E6%A0%87%E8%AE%B0">embed标记</a></li><li><a href="#%E5%B1%9E%E6%80%A7%E5%80%BC%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AF%B4%E6%98%8E">属性值格式的说明</a></li></ul></li><li><a href="#%E5%A4%84%E7%90%86%E8%B6%85%E9%93%BE%E6%8E%A5">处理超链接</a></li></ul></li><li><a href="#response%E5%AF%B9%E8%B1%A1">response对象</a><ul><li><a href="#%E5%8A%A8%E6%80%81%E5%93%8D%E5%BA%94contenttype%E5%B1%9E%E6%80%A7">动态响应contenttype属性</a></li><li><a href="#response%E7%9A%84http%E6%96%87%E4%BB%B6%E5%A4%B4">response的http文件头</a></li><li><a href="#response%E9%87%8D%E5%AE%9A%E5%90%91">response重定向</a></li></ul></li><li><a href="#session%E5%AF%B9%E8%B1%A1">session对象</a><ul><li><a href="#session%E5%AF%B9%E8%B1%A1%E7%9A%84id">session对象的id</a></li><li><a href="#session%E5%AF%B9%E8%B1%A1%E4%B8%8Eurl%E9%87%8D%E5%86%99">session对象与URL重写</a></li><li><a href="#session%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE">session对象存储数据</a></li><li><a href="#session%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%AD%98%E6%9C%9F%E9%99%90">session对象的生存期限</a></li></ul></li><li><a href="#applicable%E5%AF%B9%E8%B1%A1">applicable对象</a><ul><li><a href="#application-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">application 对象的常用方法</a></li></ul></li><li><a href="#out%E5%AF%B9%E8%B1%A1">out对象</a></li><li><a href="#%E5%B0%8F%E6%80%BB%E7%BB%93">小总结</a></li></ul><h1 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h1><p>在JSP中，内置对象request封装了用户提交的信息，那么该对象调用相应的方法可以获取封装的信息，即使用该对象可以获取用户提交的信息。</p><p>用户通常使用HTML的form表单(也称form标记)请求访问服务器的某个JSP页面（或servlet，见第六章），并提供必要的信息给请求的JSP页面，格式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>  <span class="hljs-attr">action</span>= <span class="hljs-string">&quot;请求访问的页面或Servlet&quot;</span>  <span class="hljs-attr">method</span>= <span class="hljs-string">get</span> | <span class="hljs-attr">post</span>  &gt;</span><br>    提交手段<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>其中<code>&lt;form&gt;</code>是form表单的开始标签、<code>&lt;/from&gt;</code>是结束标签 ,开始标签和结束标签之间的是form表单的标记体内容</li><li><code>action</code>是from表单的属性,其属性值给出表单请求访问的JSP页面或servlet </li><li><code>method</code>属性取值get或post<ul><li>使用 get 方法提交的信息会在提交的过程中显示在浏览器的地址栏中</li><li>使用 post 方法提交的信息不会显示在浏览器的地址栏中</li></ul></li></ul><p>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;tom.jsp&quot;</span> <span class="hljs-attr">method</span>= <span class="hljs-string">&quot;post&quot;</span> &gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;boy&quot;</span> <span class="hljs-attr">value</span>= <span class="hljs-string">&quot;ok&quot;</span> /&gt;</span> <br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure><h2 id="获取用户提交的信息"><a href="#获取用户提交的信息" class="headerlink" title="获取用户提交的信息"></a>获取用户提交的信息</h2><p><strong><code>request对象</code>获取用户提交信息的最常用的方法是<code>getParameter(String s)</code></strong></p><ul><li>注意:如果form表单中的action请求的页面是当前页面，可以用双引号””或单引号代替当前页面，即写成action&#x3D;””或action &#x3D;’’，注意双引号或单引号中不能含有空格。也可省略action参数，即不显式写出action参数。</li><li>注意:使用request对象获取当前页面提交的信息时要格外小心，若当用户在浏览器中输入页面地址请求页面时，用户还没有机会提交数据,那么页面在执行 <code>request.getParameter(String s)</code> 得到的就是一个空对象 Java解释器就会提示出现了NullPointerException异常。因此，为了避免在运行时出NullPointerException异常,可加一个判断语句 来判断 得到的是否是空对象</li></ul><h2 id="处理汉字信息"><a href="#处理汉字信息" class="headerlink" title="处理汉字信息"></a>处理汉字信息</h2><p>用户提交的信息中如果含有汉字字符或其他非ASCII字符的信息，就必须进行特殊的处理方式，防止出乱码现象。</p><ol><li>JSP页面文件的编码为utf-8编码。</li><li>内置对象request在获取信息之前调用setCharacterEncoding方法设置编码为utf-8（默认是iso-8859-1）就可以避免乱码现象<br>代码如下：</li></ol><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">request.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="常用方法举例"><a href="#常用方法举例" class="headerlink" title="常用方法举例"></a>常用方法举例</h2><p>request的getParameter方法获取form表单提交的有关信息，但实际上，request对象调用相关方法可以获取请求的许多细节信息。<br>内置对象request常用方法如下：</p><ol><li><code>String getProtocol()</code>  获取用户向服务器提交信息所使用的通信协议，比如http&#x2F;1.1等。</li><li><code>String getServletPath()</code>  获取用户请求的JSP页面文的名字（带目录符号\，例如\hello.jsp）。</li><li><code>String getContextPath()</code> 获取用户请求的当前Web服务目录（例如ch4）。</li><li><code>int getContentLength()</code>  获取用户提交的整个信息的长度。</li><li><code>String getMethod()</code>  获取用户提交信息的方式，比如：post或get.</li><li><code>String getRemoteAddr()</code>  获取用户的IP地址。</li><li><code>String getRemoteHost()</code>  获取用户机的名称（如果获取不到，就获取IP地址）。</li><li><code>String getServerName()</code>  获取服务器的名称。</li><li><code>String getServerPort()</code>  获取服务器的端口号。</li></ol><h2 id="处理html标记-不区分大小写"><a href="#处理html标记-不区分大小写" class="headerlink" title="处理html标记-不区分大小写"></a>处理html标记-不区分大小写</h2><h3 id="form-标记-form表单"><a href="#form-标记-form表单" class="headerlink" title="form 标记-form表单"></a>form 标记-form表单</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>  <span class="hljs-attr">action</span>= <span class="hljs-string">&quot;请求访问的页面或servlet&quot;</span>  <span class="hljs-attr">method</span> = <span class="hljs-string">get</span> | <span class="hljs-attr">post</span>  &gt;</span><br>    各种提交手段<br>    提交键<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>form表单标记经常将下列标记作为form表单的子标记，以便提供提交数据的手段，这些标记都以GUI形式出现，方便用户输入或选择数据，比如，文本框、下拉列表、滚动列表等。</p><ul><li><code>&lt;input …../&gt;</code></li><li><code>&lt;select   …   &gt;&lt;/select&gt;</code></li><li><code>&lt;option …..&gt;  &lt;/option&gt;</code></li><li><code>&lt;textArea ….&gt; &lt;/textArea&gt;</code></li></ul><h3 id="input标记"><a href="#input标记" class="headerlink" title="input标记"></a>input标记</h3><p>在<code>form表单</code>将<code>input标记</code>作为子标记来指定<code>form表单</code>中数据的输入方式以及<code>form表单</code>的提交键<br>input 标记属于空标记,即没有标记体,所以input标记没有开始标签和结束标签,基本格式为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;GUI对象&quot;</span> <span class="hljs-attr">name</span>= <span class="hljs-string">&quot;GUI对象的名子&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;GUI中的默认值&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>input中type属性的值指定输入方式的GUI对象,name属性的值指定这个GUI对象的名字</p><ul><li>Tom服务器的内置对象request通过name指定的名字来获取GUI对象中提交的数据.</li></ul><p>GUI对象可以是text(文本框)、checkbox(复选框)、submit(提交键)等</p><ol><li>文本框text<br>例如:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;m&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;h&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;8&quot;</span> <span class="hljs-attr">algin</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;9&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>如果用户没有在text输入任何信息，就单击form表单中的submit提交键，request对象调用getParameter方法将获取由value指定的默认值(text中显示的默认值)，如果value未指定任何值，getParameter方法获取的字符串的长度为0，即该字符串为””</li></ol><ul><li>size 是 text的长度(单位是字符)</li><li>algin 是 text 在浏览器窗口中的对齐方式</li><li>maxlength 指定 text 可输入的最多字符</li><li></li></ul><ol start="2"><li>单选框radio</li></ol><p>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hi&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span> <span class="hljs-attr">algin</span>= <span class="hljs-string">&quot;top&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;ok&quot;</span> /&gt;</span>男生<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hi&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span> <span class="hljs-attr">algin</span>= <span class="hljs-string">&quot;top&quot;</span>  /&gt;</span>女生<br></code></pre></td></tr></table></figure><ul><li>其中value指定radio的值，如果几个单选键的name取值相同，那么同一时刻只能有一个被选中。</li><li>request对象调用getParameter方法获取被选中的radio中value属性指定的值。</li><li>checked如果取值是一个非空的字符串，那么该单选框的初始状态就是选中状态。</li></ul><ol start="3"><li>复选框checkbox<br>例如:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>= <span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;A&quot;</span>  <span class="hljs-attr">algin</span>= <span class="hljs-string">&quot;top&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;ok&quot;</span> /&gt;</span>足球<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>= <span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;B&quot;</span>  <span class="hljs-attr">algin</span>= <span class="hljs-string">&quot;top&quot;</span>  /&gt;</span>围棋<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>= <span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;C&quot;</span>  <span class="hljs-attr">algin</span>= <span class="hljs-string">&quot;top&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;ok&quot;</span> /&gt;</span>乒乓球<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>= <span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;D&quot;</span>  <span class="hljs-attr">algin</span>= <span class="hljs-string">&quot;top&quot;</span>  /&gt;</span>篮球<br></code></pre></td></tr></table></figure></li></ol><ul><li>其中value指定checkbox的值。复选框与单选框的区别就是可以多选，即如果几个checkbox的name取值相同，那么同一时刻可有多个chekbox被选中。</li><li>request对象<strong>需调用getParameterValues方法（不是getParameter方法）</strong>获取被选中的多个checkbox中value属性指定的值。</li><li>checked如果取值是一个非空的字符串，那么该复选框的初始状态就是选中状态。</li></ul><ol start="4"><li>口令框password<br>用户输入的信息用<code>*</code>回显,防止他人偷看口令<br>例如:  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>= <span class="hljs-string">&quot;password&quot;</span>  <span class="hljs-attr">name</span>= <span class="hljs-string">&quot;me&quot;</span>  <span class="hljs-attr">size</span>= <span class="hljs-string">&quot;12&quot;</span>  <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;30&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ul><li>用户在口令框中输入tiger，单击提交键，tiger将被提交给form表单请求的页面</li><li>请求的页面的内置对象request调用getParameter方法获取password提交的值tiger（password仅仅起着不让别人偷看的作用，不提供加密措施）。</li></ul><ol start="5"><li><p>隐藏hidden<br>input没有可见的输入界面,form表单会将input标记中的value属性的值提交给所请求的页面<br>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>= <span class="hljs-string">&quot;hidden&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;nogui&quot;</span>  <span class="hljs-attr">value</span>= <span class="hljs-string">&quot;hello&quot;</span>  /&gt;</span><br></code></pre></td></tr></table></figure><p>用户单击form表单中的submit提交键，那么form表单所请求的页面的内置对象request调用getParameter方法将获取由value指定的值hello。</p></li><li><p>提交键submit<br>为了能把form表单的数据提交给服务器，一个form表单至少包含一个提交键(可以有多个提交键)<br>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>= <span class="hljs-string">&quot;submit&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;me&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;确定&quot;</span>  <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;12&quot;</span>  /&gt;</span><br></code></pre></td></tr></table></figure><p>单击提交键后，form表单请求的页面才有机会获取form表单提交的各个数据。</p></li><li><p>重置键：reset<br>重置键将表单中输入的数据清空，以便重新输入数据<br>例如：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="select、option标记-下拉列表或滚动列表"><a href="#select、option标记-下拉列表或滚动列表" class="headerlink" title="select、option标记-下拉列表或滚动列表"></a>select、option标记-下拉列表或滚动列表</h3><p>select标记将option作为子标记,形成下拉列表或滚动列表  </p><ul><li>Tom服务器的内置对象request通过name指定的名字来获取GUI对象中提交的数据.<br>下来列表的基本格式为:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myName&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;item1&quot;</span>&gt;</span>文本描述<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;item2&quot;</span>&gt;</span>文本描述<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>   … …<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>在select中添加size属性的值就变成了滚动列表,size的值是滚动列表的可见行的数目.<br>滚动列表的基本格式:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myName&quot;</span><span class="hljs-attr">size</span>=<span class="hljs-string">&#x27;正整数&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;item1&quot;</span>&gt;</span>文本描述<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;item2&quot;</span>&gt;</span>文本描述<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>   … …<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="textarea标记"><a href="#textarea标记" class="headerlink" title="textarea标记"></a>textarea标记</h3><p><code>&lt;textArea&gt;</code>是一个能输入或显示多行文本的文本区,在<code>form表单</code>中使用<code>&lt;textArea&gt;</code>作为子标记可以提交多行文本给所请求的JSP页面<br>基本格式为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textArea</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;名字&quot;</span>  <span class="hljs-attr">rows</span>= <span class="hljs-string">&quot;文本可见行数&quot;</span>  <span class="hljs-attr">cols</span>= <span class="hljs-string">&quot;文本可见列数&quot;</span> &gt;</span><br>  提交或显示的数据<br><span class="hljs-tag">&lt;/<span class="hljs-name">textArea</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="style样式标记"><a href="#style样式标记" class="headerlink" title="style样式标记"></a>style样式标记</h3><p>style标记可用于定义HTML其他标记中的字体样式<br>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">   <span class="hljs-selector-id">#textStyle</span>&#123;</span><br><span class="language-css">      <span class="hljs-attribute">font-family</span>:宋体;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">18</span>;<span class="hljs-attribute">color</span>:blue </span><br><span class="language-css">   &#125;</span><br><span class="language-css">   <span class="hljs-selector-id">#tom</span>&#123;</span><br><span class="language-css">      <span class="hljs-attribute">font-family</span>:黑体;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">16</span>;<span class="hljs-attribute">color</span>:black </span><br><span class="language-css">   &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>#</code>字符之后的字符序列是样式名称，例如<code>#textStyle</code>给出的样式名称是<code>textStyle</code>（起一个自己喜欢且容易理解的名字），其它html标记可以让其<code>id</code>属性值是样式名称来使用这个样式。<br>例如，段落标记p就可以如下使用textStyle样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;textStyle&quot;</span>&gt;</span>你好<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>textArea标记如下使用tom样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textArea</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;english&quot;</span>  <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;tom&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">5</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">38</span>&gt;</span>大家好 <span class="hljs-tag">&lt;/<span class="hljs-name">textArea</span>&gt;</span><br></code></pre></td></tr></table></figure><p>input标记如下使用textStyle样式：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;textStyle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="table标记-主要用于显示数据-不能提交数据"><a href="#table标记-主要用于显示数据-不能提交数据" class="headerlink" title="table标记-主要用于显示数据 不能提交数据"></a>table标记-主要用于显示数据 不能提交数据</h3><p>格式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>  <span class="hljs-attr">border</span> =<span class="hljs-string">&quot;边框的宽度&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>  <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;该行的宽度&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>  <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;单元格的宽度&quot;</span> &gt;</span>单元格中的数据<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>         …<br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>  <span class="hljs-attr">width</span>= <span class="hljs-string">&quot;单元格的宽度&quot;</span> &gt;</span>单元格中的数据<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> …<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>…<br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a><image>标记</h3><p>不能用于提交数据，用于显示图像。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图像文件的URL&quot;</span> &gt;</span>描述文字<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span> <br></code></pre></td></tr></table></figure><h3 id="embed标记"><a href="#embed标记" class="headerlink" title="embed标记"></a>embed标记</h3><p>不能用于提交数据。使用embed标记可以播放音乐和视频，当浏览器执行该标记时，会把浏览器所在机器上的默认播放器嵌入到浏览器中，以便播放音乐或视频文件。embed标记的基本格式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">embed</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;音乐或视频文件的URL&quot;</span> &gt;</span>描述文字&lt;/embed &gt; <br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">embed</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;音乐或视频文件的URL&quot;</span> /&gt;</span> <br></code></pre></td></tr></table></figure><p>如果音乐成视频文件和当前页面在同一 Web 服务目录中,embed 标记中 sre 属性的值较是该文件的名字;如果视频文件在当前 Web 服务目录一个子目录中,比如 avi 子目录中,那么embed 标记中 sre 属性的值就是“avi&#x2F;视频文件的名字”。<br>embed标记中经常使用的属性及取值如下: </p><ul><li>autostart 属性值 true 或 false,autostart 属性的值用来指定音乐或视频文件传送完毕后是否立刻播放，该属性的默认值是 false。</li><li>loop 属性取值正整数指定音乐或视频文件重复播放的次数,取值-1 为无限循环播放。</li><li>width 和 height 属性取值均为正整数，用 width 和 height 属性的值指定播放器的宽和高,如果省略 width 和 height 属性,将使用默认值。</li></ul><h3 id="属性值格式的说明"><a href="#属性值格式的说明" class="headerlink" title="属性值格式的说明"></a>属性值格式的说明</h3><p>许多HTML标记的中都有属性，并指定属性的值，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testAmount&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">10</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>中的type，name ，value都是input标记的属性，属性值可以用双引号括起，也可以用单引号括起,或者不用任何符号.<br>比如type属性的值可以用双引号括起”text”，也可以用单引号括起’text’或者不用任何符号text.  </p><ul><li>一个好的习惯是用单引号括起。例如，下列超链接标记中的href的属性值用单引号括起。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> = <span class="hljs-string">&#x27;example4_1.jsp&#x27;</span>&gt;</span>超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="处理超链接"><a href="#处理超链接" class="headerlink" title="处理超链接"></a>处理超链接</h2><p>超链接标记</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">链接的页面地址</span> &gt;</span>文字说明<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>是一个常用标记。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> =<span class="hljs-string">&quot;example4_9_receive.jsp&gt;购买&lt;/a&gt;</span></span><br></code></pre></td></tr></table></figure><p>用户单击超链接标记的文字说明，可以访问超链接给出的链接页面。<br>使用超链接标记时还可以增加参数，以便向所链接的页面传递值，格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">链接的页面地址?参数1</span>=<span class="hljs-string">字符串1&amp;参数2</span>=<span class="hljs-string">字符串2…</span> &gt;</span>文字说明<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span> =<span class="hljs-string">&quot;example4_9_receive.jsp?id=A1001&amp;price=8765&quot;</span>&gt;</span>购买<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>超链接所链接的页面，使用request调用getParameter(“参数”)获得超链接的参数传递过来的参数的值，即字符串。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">String idStr = request.getParameter(&quot;id&quot;);<br></code></pre></td></tr></table></figure><p>需要注意的是，超链接标记向所链接的页面传递的参数的值，即字符串中不允许含有非ASCII字符（例如汉字等）。</p><h1 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h1><p>与request对象相对应的对象是response对象。可以用response对象对用户的请求作出动态响应，向用户端发送数据。</p><h2 id="动态响应contenttype属性"><a href="#动态响应contenttype属性" class="headerlink" title="动态响应contenttype属性"></a>动态响应contenttype属性</h2><ul><li>页面用page指令设置页面的contentType属性的值，那么Tomcat服务器将按着这种属性值作出响应，将页面的静态部分返回给用户，用户浏览器接收到该响应就会使用相应的手段处理所收到的信息。</li><li>page指令只能为contentType指定一个值来决定响应的MIME类型，如果想动态的改变这个属性的值来响应用户，就需要使用response对象的setContentType(String s)方法来改变contentType的属性值</li><li>当用setContentType(String s)方法动态改变了contentType的属性值，即响应的MIME类型，Tomcat服务器就会按着新的MIME类型将JSP页面的输出结果返回给用户。</li></ul><h2 id="response的http文件头"><a href="#response的http文件头" class="headerlink" title="response的http文件头"></a>response的http文件头</h2><p>response对象可以使用方法</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">addHeader(String  head,String value);<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">setHeader(String head ,String value);<br></code></pre></td></tr></table></figure><p>动态添加新的响应头和头的值，将这些头发送给用户的浏览器。如果添加的头已经存在，则先前的头被覆盖</p><h2 id="response重定向"><a href="#response重定向" class="headerlink" title="response重定向"></a>response重定向</h2><p>在某些情况下,当响应用户时,需要将用户重新引导至另一个页面,例如:如果用户输入的form表单信息不完整,就会再被引导到该form表单的输入页面</p><ul><li>response的sendRedirect(URL url)方法实现用户的重定向，即让用户从一个页面跳转到sendRedirect(URL: url)中url指定的页面。</li><li>当使用sendRedirect(URL url)方法将用户从当前页面重定向另一个页面时，Tomcat服务器还是要把当前JSP页面执行完毕后才实施重定向（跳转）操作，但Tomcat服务器不再给用户看当前页面的执行效果。</li><li>如果在执行sendRedirect(URL url)方法后，紧接着执行了return返回语句，那么Tomcat服务器会立刻结束当前JSP页面的执行。</li></ul><h1 id="session对象"><a href="#session对象" class="headerlink" title="session对象"></a>session对象</h1><p>HTTP协议是一种无状态协议。一个用户向服务器发出请求（request），然后服务器返回响应（response），在服务器端不保留用户的有关信息，因此当下一次发出请求时，服务器无法判断这一次请求和以前的请求是否属于同一用户。</p><ul><li>**Tomcat服务器可以使用内置session对象（会话）记录用户的信息。内置对象session由Tomcat服务器负责创建.<br>**</li></ul><h2 id="session对象的id"><a href="#session对象的id" class="headerlink" title="session对象的id"></a>session对象的id</h2><ul><li>当一个用户首次访问web服务目录中的一个JSP页面时，Tomcat服务器产生一个session对象，这个session对象调用相应的方法可以存储用户在访问该web服务目录中各个页面期间提交的各种信息。</li><li>这个session对象被分配了一个String类型的id号，Tomcat服务器同时将这个id号发送到用户端，存放在用户（浏览器）的Cookie中。这样，session对象和用户之间就建立起一一对应的关系，即每个用户都对应着一个session对象（称作用户的会话），不同用户（不同浏览器）的session对象互不相同，具有不同的id号码。</li><li>当用户再访问该Web服务目录的其它页面时，Tomcat服务器不再分配给用户的新session对象，而是使用完全相同的一个，直到session对象达到了最大生存时间或用户关闭自己的浏览器或Tomcat服务器关闭，Tomcat服务器将销毁用户的session对象</li><li><strong>简单地说，用户（浏览器）在访问一个Web服务目录期间，服务器为该用户分配一个session对象（称作和该用户的会话），服务器可以在各个页面使用这个session记录当前用户的有关信息。而且服务器保证不同用户的session对象互不相同。</strong><br>注: 同一个用户在不同的Web服务目录中的session是互不相同的。</li></ul><h2 id="session对象与URL重写"><a href="#session对象与URL重写" class="headerlink" title="session对象与URL重写"></a>session对象与URL重写</h2><ul><li>session对象能和用户建立起一一对应关系依赖于用户浏览器是否支持Cookie。</li><li>如果用户不支持Cookie，JSP页面可以通过URL重写来实现session对象的唯一性。<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">String str=response.encodeRedirectURL(<span class="hljs-string">&quot;example4_13_b.jsp&quot;</span>);<br></code></pre></td></tr></table></figure>然后将连接目标写成<code>&lt;%= str %&gt;</code></li></ul><p>例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">&quot;example4_13_b.jsp&quot;</span>  method=post &gt;<br></code></pre></td></tr></table></figure><p>更改为：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;form action=&lt;%= str %&gt;  method=post &gt;<br></code></pre></td></tr></table></figure><h2 id="session对象存储数据"><a href="#session对象存储数据" class="headerlink" title="session对象存储数据"></a>session对象存储数据</h2><ol><li>public void setAttribute (String  key ,Object  obj)。 session对象可以调用该方法将参数Object指定的对象obj添加到session对象中，并为添加的对象指定了一个索引关键字，如果添加的两个对象的关键字相同，则先前添加的对象被清除。</li><li>public Object getAttribute(String key)。获取session对象索引关键字是key的对象。由于任何对象都可以添加到session对象中，因此用该方法取回对象时，应显式转化为原来的类型。</li></ol><h2 id="session对象的生存期限"><a href="#session对象的生存期限" class="headerlink" title="session对象的生存期限"></a>session对象的生存期限</h2><ul><li>session对象的生存期限依赖于session对象是否调用invalidate()方法使得session无效或session对象达到了设置的最长的“发呆”状态时间以及用户是否关闭浏览器或服务器被关闭。</li><li>所谓“发呆”状态时间是指用户对某个Web服务目录发出的两次请求之间的间隔时间（默认的发呆时间是30分钟）。</li><li>打开Tomcat安装目录中conf文件下的配置文件web.xml，找到<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure>将其中的30修改成所要求的值即可（单位为分钟）</li></ul><h1 id="applicable对象"><a href="#applicable对象" class="headerlink" title="applicable对象"></a>applicable对象</h1><p>用户第一次访问Web服务目录时，Tomcat服务器创建和该用户相对应的session对象，当用户在所访问的Web服务目录的各个页面之间浏览时，这个session对象都是同一个，而且不同用户的session对象是互不相同的。application对象也是由Tomcat服务器负责创建，但与session对象不同的是，application对象被访问该Web服务目录的所有的用户共享，但不同Web服务目录下的application互不相同。</p><h2 id="application-对象的常用方法"><a href="#application-对象的常用方法" class="headerlink" title="application 对象的常用方法"></a>application 对象的常用方法</h2><ol><li>public void setAttribute(String  key ,Object  obj)。application对象可以调用该方法将参数Object 指定的对象 obj添加到application对象中，并为添加的对象指定了一个索引关键字，如果添加的两个对象的关键字相同，则先前添加对象被清除。</li><li>public Object getAttibute(String key)。获取application对象含有的关键字是key的对象。由于任何对象都可以添加到application对象中，因此用该方法取回对象时，应显式转化为原来的类型。</li></ol><ul><li>由于application对象对所有的用户都是相同的，因此，在某些情况下，对该对象的操作需要实现同步（synchronized）处理。</li></ul><h1 id="out对象"><a href="#out对象" class="headerlink" title="out对象"></a>out对象</h1><p>out对象是一个输出流，用来向用户端输出数据。在前面的许多例子里曾多次使用out对象进行数据的输出。out对象可调用如下的方法用于各种数据的输出，<br>例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">out.print(<span class="hljs-type">boolean</span>)或out.println(<span class="hljs-type">boolean</span>) 用于输出一个布尔值。<br>out.print(<span class="hljs-type">char</span>) 或out.println(<span class="hljs-type">char</span>) 输出一个字符。<br>out.print(<span class="hljs-type">double</span>) 或out.println(<span class="hljs-type">double</span>)输出一个双精度的浮点数。<br>out.print(fload) 或out.println(<span class="hljs-type">float</span>)用于输出一个单精度的浮点数。<br>out.print(<span class="hljs-type">long</span>) 或out.println(<span class="hljs-type">long</span>)输出一个长整型数据。<br>out.print(String) 或out.println(String)输出一个String对象的字符序列。<br></code></pre></td></tr></table></figure><p>方法println和print的区别是：println会向缓存区写入一个换行，而print不写入换行。但是浏览器的显示区域目前不识别println写入的换行，如果希望浏览器显示换行，应当向浏览器写入”<br>“实现换行。</p><h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><ol><li>通过form表单请求访问某个页面 并提交信息<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>  <span class="hljs-attr">action</span>= <span class="hljs-string">&quot;请求访问的页面或Servlet&quot;</span>  <span class="hljs-attr">method</span>= <span class="hljs-string">get</span> | <span class="hljs-attr">post</span>  &gt;</span><br>    提交手段<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>用request对象获取提交的信息<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">request.getParameter(String s);<br></code></pre></td></tr></table></figure>注意:若处理汉字信息需要在前面调用setCharacterEncoding方法设置字符<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">request.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>request.getParameter(String s)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>JSP</category>
      
      <category>第四章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统概括</title>
    <link href="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/"/>
    <url>/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>计算机系统自下而上可大致分为三个部分：（注意：划分于计组的分层不同）<br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-16-43-15.png"></p><h3 id="操作系统的概念、功能"><a href="#操作系统的概念、功能" class="headerlink" title="操作系统的概念、功能"></a>操作系统的概念、功能</h3><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-16-42-18.png"><br><strong>操作系统</strong>（Operating System， OS）是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>资源，并合理地组织调<br>度计算机的工作和资源的分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本<br>的<strong>系统软件</strong>。<br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-16-48-57.png"></p><ol><li><p>操作系统是系统资源的管理者</p><ul><li>提供的功能<ul><li>处理机管理</li><li>存储器管理</li><li>文件管理</li><li>设备管理</li></ul></li><li>目标<ul><li>高效、安全</li></ul></li></ul></li><li><p>操作系统向上层提供方便易用的服务（作为用户与计算机硬件系统之间的接口）</p><ul><li>直接给用户使用的<ul><li>GUI（图形用户界面）</li><li>命令结构（用户可直接使用）<ul><li>联机命令接口（又称交互式命令接口，用户说一句系统跟着做一句）</li><li>脱机命令接口（又称批处理命令接口，用户说一堆系统跟着做一堆）</li></ul></li></ul></li><li>给软件&#x2F;程序员使用的<ul><li>程序接口（由一组“系统调用”（也称“广义指令”）组成，用户通过程序间接使用）</li></ul></li></ul></li></ol><p>注意：命令接口和程序接口统称为“用户接口”</p><ol start="3"><li>操作系统是最接近硬件的一层软件<ul><li>对硬件机器的拓展，没有任何软件支持的计算机成为裸机，通常把覆盖了软件的机器成为扩展机器，又称为虚拟机</li></ul></li></ol><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-16-57-44.png"></p><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。  </p><ul><li>常考易混概念——并行：指两个或多个事件在同一时刻同时发生。<br>  单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行<br>  多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</li><li>操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。操作系统的并发性是通过分时得以实现的。</li></ul><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><ul><li>互斥共享方式<br>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源  </li><li>同时访问方式<br>系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问<br>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</li></ul><p><strong>并发和共享是操作系统两个最基奎的特征，两者之间互为存在的条件</strong></p><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><ul><li>虚拟技术<ul><li>空分复用技术（如虚拟存储器技术）</li><li>时分复用技术（如虚拟处理器）</li></ul></li></ul><p><strong>没有并发性，就谈不上虚拟性</strong></p><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。<br><strong>只有系统拥有并发性，才有可能导致异步性。</strong></p><h2 id="操作系统的发展和分类"><a href="#操作系统的发展和分类" class="headerlink" title="操作系统的发展和分类"></a>操作系统的发展和分类</h2><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-17-14-33.png"></p><h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-17-20-44.png"></p><h3 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h3><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-17-19-17.png"></p><p><strong>内核态、用户态的切换</strong><br>内核态-&gt;用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权<br>用户态-&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</p><p><strong>操作系统的内核</strong><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-17-25-47.png"><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-17-25-37.png"></p><p><strong>操作系统的体系结构</strong><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-17-26-10.png"></p><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-17-27-23.png"><br>中断是操作系统内核夺回CPU使用权的唯一途径（通过硬件实现）<br>内核态-&gt;用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权<br>用户态-&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权<br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-17-29-20.png"><br>不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。<br>中断处理程序一定是内核程序，需要运行在“内核态”</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-17-30-29.png"><br>系统调用 又称 广义指令<br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-27-10.png"><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-27-19.png"><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-27-39.png"><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-27-53.png"><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-34-52.png"></p><p>由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈、但这个系统堆栈也是属于该进程的。<br>陷入指令 &#x3D; trap 指令 &#x3D; 访管指令  （不是特权指令）</p><h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-28-49.png"><br><strong>大内核与微内核</strong><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-29-23.png"><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-29-31.png"><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-29-55.png"><br>微内核构架，是指将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。<br>微内核结构将操作系统划分为两大部分：微内核和多个服务器。微内核是指精心设计的、能实现操作系统最基本核心功能的小型内核，通常包含： </p><ol><li>与硬件处理紧密相关的部分；</li><li>一些较基本的功能;</li><li>客户和服务器之间的通信。<br>这些部分只是为构建通用操作系统提供一个重要基础,这样就可以确保将内核做得很小。操作系统中的绝大部分功能都放在微内核外的一组服务器（进程）中实现，如用于提供对进程（线程）进行管理的进程（线程）服务器、提供虚拟存储器管理功能的虚拟存储器服务器等，它们都是作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现交互的。<br>单机环境下的客户&#x2F;服务器模式:<br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-23-22-51-18.png"><br>微内核的特点：  </li><li>拓展性和灵活性</li><li>可靠性和安全性</li><li>可移植性</li><li>分布式计算<br><strong>分层结构</strong><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-30-20.png"><br>分层法是将操作系统分为若干层，最底层（层0）为硬件，最高层（层N）为用户接口，每层只能调用紧邻它的低层的功能和服务（单向依赖）。</li></ol><p><strong>模块化</strong><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-30-32.png"><br>在划分模块时，如果将模块划分得太小，虽然能降低模块本身的复杂性，但会使得模块之间的联系过多，造成系统比较混乱；如果模块划分得过大，又会增加模块内部的复杂性，显然应在两者间进行权衡。此外，在划分模块时，要充分考虑模块的独立性问题，因为模块独立性越高， 各模块间的交互就越少，系统的结构也就越清晰。衡量模块的独立性主要有两个标准： </p><ul><li>内聚性，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。 </li><li>耦合度，模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。</li></ul><p><strong>外核</strong><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-37-42.png"></p><h2 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h2><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-38-11.png"><br>常见操作系统的引导过程如下： </p><ol><li>激活CPU。激活的CPU读取ROM中的boot程序，将指令寄存器置为BIOS （基本输入&#x2F;输出系统）的第一条指令，即开始执行BIOS的指令。 </li><li>硬件自检。启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障。如有故障，主板会发出不同含义的蜂鸣，启动中止：如无故障，屏幕会显示CPU、内存、硬盘等信息。 </li><li>加载带有操作系统的硬盘。硬件自检后，BIOS开始读取Boot Sequence （通过CMOS里保存的启动顺序，或者通过与用户交互的方式），把控制权交给启动顺序排在第一位的存储设备， 然后CPU将该存储设备引导扇区的内容加载到内存中。 </li><li>加载主引导记录MBRo硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其他启动设备，就会死机。主引导记录MBR的作用是告诉CPU去硬盘的哪个主分区去找操作系统。 </li><li>扫描硬盘分区表，并加载硬盘活动分区。MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。 </li><li>加载分区引导记录PBR。读取活动分区的第一个扇区，这个扇区称为分区引导记录（PBR）,其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。 </li><li>加载启动管理器。分区引导记录搜索活动分区中的启动管理器，加载启动管理器。 </li><li>加载操作系统</li></ol><ul><li>BIOS:Basic Input Output System 基本输入输出系统</li><li>例子：为一个裸机安装操作系统<ol><li>一般要先进入BIOS系统，选择安装模式</li><li>安装系统的过程，其实是将操作系统相关数据写入硬盘的过程（C盘）</li><li>安装完毕，正常开机启动，操作系统相关数据从硬盘加载到RAM（即一般我们说的“内存条”）中，才能被CPU处理</li></ol></li><li>裸机里有什么？<ul><li>裸机的主板上有ROM、RAM、有空空如也的硬盘</li><li>一台裸机中只有ROM中有数据，包含着BIOS（主板出厂时被写入的）</li></ul></li></ul><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-40-24.png"><br><img src="/2023/05/22/OS-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E6%8B%AC/2023-05-22-19-40-35.png"></p><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><ol><li>在计算机科学中，<strong>Shell</strong>俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（command interpreter，<strong>命令解析器</strong>）。它类似于DOS下的COMMAND.COM和后来的<strong>cmd.exe</strong>。它接收用户命令，然后调用相应的应用程序。<ul><li>操作系统与用户通信接口通常不包括（D）A.shell B.命令解释器 C.广义指令 D.缓存管理指令</li><li>命令解释器，命令解析器都属于 命令接口</li><li>命令解释器 就是 cmd.exe</li></ul></li><li>系统调用 又称 广义指令</li><li>系统调用的目的是请求系统服务</li><li>顺序性不属于多道程序设计的基本特征 ，其属于单道程序设计的基本特征</li><li>单处理机系统中处理机与通道可并行</li><li>计算机开机后，操作系统最终被加载到 RAM 里<ul><li>RAM(random-access memory)随机访问存储器 可随机读写，读写速度快，断电后数据消失（内存条）</li><li>ROM(read only memory)只读存储器 数据写入之后不可更改，即使断电数据也不消失 （DVD、VCD）</li><li>EPROM(Electrically Programmable Read-Only-Memory)电可编程序只读存储器 一种特殊的ROM</li></ul></li><li>早期的多道批处理操作系统会将所有的进程的数据全部调入主存，再让多道程序并发执行，即使不支持虚拟存储管理，也能实现“多道程序并发”</li><li>进制多并不意味着CPU利用率高，进程数量越多，进程之间的竞争越激烈，甚至可能因为资源竞争而出现死锁现象</li><li>中断技术使得多道批处理系统的I&#x2F;O设备可与CPU并行工作，当一道程序因I&#x2F;O请求而停止时，CPU便立即转去运行另一道程序</li><li>要注意区分不同语境下“并行”所描述的对象<ul><li>在说明操作系统特点时，我们说，单CPU的操作系统具有并发性而不具有并行性，在这里，“并行”描述的是进程之间的关系，单CPU操作系统无法真正同时运行多个进程，而只能从微观上分时交替地运行多个进程，符合并发却称不上并行</li><li>而这里在说明多任务操作系统的特点时，“并行”指的是多个任务的关系而非多个进程的关系。虽然多进程在单CPU系统无法并行，但是多任务却可以，比如，任务A是执行算术运算，它占用CPU，任务B是执行l0，它不占用CPU，因此这两个任务是可以并行的，此即单CPU多任务操作系统的并行性。</li></ul></li><li>进程调度由调度算法决定CPU使用权，由操作系统实现，不需要（特殊）硬件支持。<ul><li>时钟管理，需要硬件定时器，定期发出时钟脉冲</li><li>地址映射，需要地址变换相关的硬件机构，如页表寄存器、TLB等</li><li>中断系统，需要中断向量地址形成部件，将中断信号映射为中断向量（具体见计组）</li></ul></li><li>中断发生后，进入中断处理的程序属于操作系统程序（内核程序）（具体见计组JMP无条件跳转指令）<ul><li>进入中断处理的程序 与 中断处理程序不同 ，不过中断处理程序也是内核程序</li></ul></li><li>置时钟指令 只能在核心态下运行 因为若能在用户态下运行，那么一个用户进程可在时间片还未到之前把时钟改回去，从而导致时间片永远用不完，进而导致该用户进程一直占用CPU，这显然不合理<ul><li>寄存器清零（通用寄存器清零，一些特殊的寄存器如PSW不允许用户态修改）、读时钟指令、取数指令，均可在汇编语言中涉及，因此都可以运行在用户态</li></ul></li><li>CPU处于核心态时，它可以执行的指令是 除 访管指令 的全部指令</li><li>进程调度程序是内核程序</li><li>中断处理时保存的数据<ul><li>硬件负责<ul><li>程序计数器PC</li><li>程序状态字PSW</li></ul></li><li>操作系统负责<ul><li>其他有必要保存的信息，如某些通用寄存器（不是所有通用寄存器都需要保存，具体需要操作系统判断）</li></ul></li><li>快表tlb和cache不需要 他们里面都是副本</li></ul></li><li>假定指令已装入指令寄存器，则执行时不可能导致CPU从用户态变为内核态（系统态）的是 NOT R0;寄存器RO的内容取非<ul><li>DIV RO, R1 ;（R0）&#x2F;（Rl）—R0 （除数取0，产生内中断）</li><li>INT n ; 产生软中断（内中断，陷入指令）</li><li>MOV RO, addr ;把地址addr处的内存数据放入寄存器R0（可能产生缺页中断）</li></ul></li><li>“DMA传送结束”属于中断（外中断）；“访存时缺页”、“整数除以0”、“存储保护错”属于异常</li><li>时钟中断的主要工作是处理和时间有关的信息及决定是否执行调度程序。和时间有关的所有信息包括：系统时间、进程的时间片、延时、使用CPU的时间、各种定时器。</li><li>通用操作系统 如 安卓 <ul><li>专用操作系统 如 火箭的操作系统</li></ul></li><li>发起系统调用是在用户态 执行系统调用服务程序 是在内核态</li><li>不同的操作系统为应用程序提供了不统一的系统调用接口</li><li>通常可以从四个方面来描述微内核OS：<ol><li>内核足够小</li><li>基于客户&#x2F;服务器模式</li><li>应用“机制与策略分离”原理</li><li>采用面向对象技术</li></ol></li><li>操作系统的引导程序位于磁盘活动分区的引导扇区中。引导程序分为两种：<ul><li>一种是位于ROM中的自举程序（BIOS的组成部分），用于启动具体的设备；</li><li>另一种是位于装有操作系统硬盘的活动分区的引导扇区中的引导程序（称为启动管理器），用于引导操作系统。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件管理</title>
    <link href="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><ul><li>文件的逻辑结构<br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-17-36-09.png"><ul><li>无结构文件(流式文件)</li><li>有结构文件(记录式文件)<br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-17-36-26.png"><ul><li>顺序文件<ul><li>可变长记录</li><li>定长记录<ul><li>串结构</li><li>顺序结构</li></ul></li></ul></li><li>索引文件</li><li>索引顺序文件</li></ul></li></ul></li></ul><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><ul><li>文件的物理结构(文件分配方式)<br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-17-42-55.png"><ul><li>连续分配(可顺序访问,也可随机访问,不方便拓展)</li><li>链接分配(只能顺序访问,不可随机访问,方便拓展)<ul><li>隐式链接</li><li>显示链接(FAT)</li></ul></li><li>索引分配(可顺序访问,也可随机访问(没连续结构快),方便拓展)<br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-17-44-37.png"><ul><li>链接方案(类似隐式链接)</li><li>多层索引</li><li>混合索引</li></ul></li></ul></li></ul><h3 id="文件的逻辑结构和物理结构"><a href="#文件的逻辑结构和物理结构" class="headerlink" title="文件的逻辑结构和物理结构"></a>文件的逻辑结构和物理结构</h3><p><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-19-24-07.png"></p><ul><li><p>文件的逻辑结构</p><ul><li>无结构文件(流式文件)</li><li>有结构文件(记录式文件)<ul><li>顺序文件<ul><li>可变长记录</li><li>定长记录<ul><li>串结构</li><li>顺序结构</li></ul></li></ul></li><li>索引文件</li><li>索引顺序文件</li></ul></li></ul></li><li><p>文件的物理结构(文件分配方式)</p><ul><li>连续分配(可顺序访问,也可随机访问,不方便拓展)</li><li>链接分配(只能顺序访问,不可随机访问,方便拓展)<ul><li>隐式链接</li><li>显示链接(FAT)</li></ul></li><li>索引分配(可顺序访问,也可随机访问(没连续结构快),方便拓展)<ul><li>链接方案(类似隐式链接)</li><li>多层索引</li><li>混合索引</li></ul></li></ul></li></ul><p>注:索引文件比较有歧义,需结合语境判断  </p><p>“文件的某种逻辑结构支持随机存取&#x2F;随机访问”是指：采用这种逻辑结构的文件，可以根据记录号直接算出该记录对应的逻辑地址（逻辑块号，块内地址） </p><ul><li>注意区分 物理结构的索引表 和 逻辑结构的索引表<br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-16-12-25.png"> <ul><li>索引文件的分配表：用户自己建立的，映射：关键字 → 记录存放的逻辑地址</li><li>索引分配的分配表：操作系统建立的，映射：逻辑块号 → 物理块号</li></ul></li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-17-39-40.png"></p><h2 id="文件存储空间的管理（对空闲磁盘块的管理）"><a href="#文件存储空间的管理（对空闲磁盘块的管理）" class="headerlink" title="文件存储空间的管理（对空闲磁盘块的管理）"></a>文件存储空间的管理（对空闲磁盘块的管理）</h2><p><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-19-27-16.png"></p><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><ul><li>向上层提供的几个基本的功能<ul><li>创造文件(create系统调用)</li><li>删除文件(delete系统调用)</li><li>读文件(read系统调用)</li><li>写文件(write系统调用)</li><li>打开文件(open系统调用)</li><li>关闭文件(close系统调用)<br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-19-27-54.png"><br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-16-36-58.png"><br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-17-10-07.png"></li></ul></li></ul><h2 id="文件的共享"><a href="#文件的共享" class="headerlink" title="文件的共享"></a>文件的共享</h2><p><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-19-28-27.png"></p><ul><li>基于索引结点的共享方式（硬链接）<br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-19-30-32.png"></li><li>基于符号链的共享方式（软链接）<br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-19-31-31.png"></li></ul><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><ul><li><p>UNIX操作系统中，所有设备都被视为特殊的文件，因为UNIX操作系统控制和访问外部设备的方式和访问一个文件的方式都是相同的。</p></li><li><p><code>文件控制块</code>即<code>FCB</code>通常由文件基本信息，存取控制信息和使用信息组成(一个文件目录也被视为一个文件，称目录文件)，一个<code>FCB</code>就是一个<code>文件目录项</code>.</p></li><li><p>将文件描述信息从目录项中分离出来，即应用了<code>索引结点</code>的方法，磁盘的盘块中可以存放更多的目录项，查找文件时可以大大减少其I&#x2F;O信息量</p></li><li><p>加密保护和访问控制两种机制相比</p><ul><li>访问控制机制的灵活性更好</li><li>加密保护机制的安全性更高</li><li>访问控制机制必须由系统实现</li></ul></li><li><p>系统级安全管理包括注册和登录</p></li><li><p>文件的逻辑结构和物理结构</p><ul><li>文件的逻辑结构<ul><li>无结构文件(流式文件)</li><li>有结构文件(记录式文件)<ul><li>顺序文件<ul><li>可变长记录</li><li>定长记录<ul><li>串结构</li><li>顺序结构</li></ul></li></ul></li><li>索引文件</li><li>索引顺序文件</li></ul></li></ul></li><li>文件的物理结构(文件分配方式)<ul><li>连续分配</li><li>链接分配<ul><li>隐式链接</li><li>显示链接(FAT)</li></ul></li><li>索引分配<ul><li>链接方案(类似隐式链接)</li><li>多层索引</li><li>混合索引</li></ul></li></ul></li><li>注:索引文件比较有歧义,需结合语境判断</li><li>注意区分 物理结构的索引表 和 逻辑结构的索引表<br><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-16-12-25.png"></li></ul></li><li><p>直接存取&#x3D;随机存取 (允许用户按任意的次序，直接存取文件中的任意一个记录，或者根据存取命令把读写指针移到文件中的指定记录处读写。)</p><ul><li>链接分配不具有随机存取特性(显式和隐式都不行)</li></ul></li><li><p>记录成组分解技术————不可跨越“块”存储记录 （如盘块长度512B，逻辑记录的固定长度为100B，则每个盘块只能存入5条记录，剩余12B没有用）</p></li><li><p>Read之前必须先Open</p></li></ul><p><img src="/2023/05/21/OS-4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/2023-05-21-16-36-47.png"></p><ul><li><p>所有的系统调用都会导致CPU从用户态切换到核心态</p></li><li><p>索引结点的数量与文件的个数有关，而与单个文件长度无关</p></li><li><p>提前读、延迟写、为文件分配连续的簇（几个盘块组成）、采用磁盘高速缓存都可以提高文件访问速度。</p></li><li><p>关于目录检索</p><ul><li>散列法具有较快的检索速度 但需要牺牲很多存储空间</li><li>顺序检索法（一般都采用该方法）对树形目录应采用文件的路径名，且从根目录 或 当前目录开始逐渐检索，只要路径名的一个分量名未找到，就应停止查找</li><li>采用顺序检索法查找完成后，可能得到的是文件的物理地址，也可能是索引结点的地址，要看操作系统有没有对FCB进行改进</li></ul></li><li><p>用户优先级是指多个用户同时请求某个文件时，应该满足谁</p></li><li><p>为一个文件的访问，常由用户访问权限和文件属性共同限制</p></li><li><p>防止文件受损常采用备份的方法保护文件</p></li><li><p>存储控制矩阵（Access Control Matrix,有的地方翻译为“访问控制矩阵”）的功能类似于访问控制表（ACL，Access Control List），用于判断用户是否有权对文件进行 读&#x2F;写&#x2F;删除或其他操作</p></li><li><p>设置当前工作目录的主要目的是 加快文件的检索速度   </p></li><li><p>多个进程共享一个文件，各进程的用户打开文件表中关于该文件的表现内容不一定相同，如读写指针、访问权限</p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>第四章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查找</title>
    <link href="/2023/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="折半查找（二分）"><a href="#折半查找（二分）" class="headerlink" title="折半查找（二分）"></a>折半查找（二分）</h3><p><img src="/2023/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-%E6%9F%A5%E6%89%BE/2023-05-23-21-49-16.png"><br>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Binary_Search</span><span class="hljs-params">(SSTable LzElemType key)</span>&#123;<br>    <span class="hljs-type">int</span> low=O,high=L.TableLen-l,mid;<br>    <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>        mid= (low+high)/<span class="hljs-number">2</span>;          <span class="hljs-comment">//取中间位置</span><br>        <span class="hljs-keyword">if</span>(L.elem［mid］==key)<br>            <span class="hljs-keyword">return</span> mid;             <span class="hljs-comment">//查找成功则返回所在位置</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(L.elem［mid］&gt;key)<br>            high=mid-l;             <span class="hljs-comment">//从前半部分继续查找</span><br>        <span class="hljs-keyword">else</span><br>            low-mid+l;              <span class="hljs-comment">//从后半部分继续查找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                      <span class="hljs-comment">//查找失败，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意与另一种<a href="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/#%E4%BA%8C%E5%88%86">二分</a>写法区分，考试以此处为准</p><h4 id="折半查找判定树的构建"><a href="#折半查找判定树的构建" class="headerlink" title="折半查找判定树的构建"></a>折半查找判定树的构建</h4><p><img src="/2023/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-%E6%9F%A5%E6%89%BE/2023-05-23-21-45-42.png"><br>要学会如何画判定二叉树，如下图 16个元素的有序表 按编号绘制的判定二叉树<br><img src="/2023/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-%E6%9F%A5%E6%89%BE/2023-05-23-21-47-47.png"><br><img src="/2023/05/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-%E6%9F%A5%E6%89%BE/2023-05-23-21-48-34.png"></p><h4 id="拓展思考"><a href="#拓展思考" class="headerlink" title="拓展思考"></a>拓展思考</h4><ul><li>折半查找时间复杂度是O(log<sub>2</sub>n)<br>  顺序查找的时间复杂度是O(n)<br>  但折半查找的速度不一定不顺序查找更快</li><li>mid向上取整时 反过来 l和r之间有偶数个元素，mid分隔后，左半部分比右半部分多一个元素</li></ul><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><ol><li><p>折半查找和二叉排序树的时间性能有时不相同</p><ul><li>折半查找查找过程构成了二叉排序树，是二叉平衡树 时间复杂度O(log<sub>2</sub>n)</li><li>而二叉排序树在不限平衡的条件下是自由发挥的 最坏情况下 查找长度为O(n)</li></ul></li><li><p>折半查找查找某个不存在的元素，求比较次数至多、至少是多少</p><ul><li>方法一：画出对应二叉排序树（左少右多）</li><li>方法二：我们已知 在二分时 若当前l与r之间有奇数个元素，则mid分隔后，左右两部分元素个数相等，若当前l和r之间有偶数个元素 ，则mid分隔后，左半部分比右半部少一个元素 。对元素为n的顺序数组进行二分对应的二叉排序树是平衡二叉树 <strong>最大高度$h&#x3D;\left \lceil \log_{2}{n+1}  \right \rceil $ 若n为奇数  若查找某个不存在的元素 查找次数至多<code>h</code>,至少要具体看是否能满足满二叉树的要求，若为满二叉树则为<code>h</code>，若不为则为<code>h-1</code>；若n为偶数 若查找某个不存在的元素 至多是 <code>h</code> 至少是 <code>h-1</code>(因为满二叉树结点树n&#x3D;2<sup>h</sup>-1,n一定为奇数) 。</strong></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2023/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-%E5%9B%BE/"/>
    <url>/2023/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><p><img src="/2023/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-%E5%9B%BE/2023-05-10-21-00-14.png"></p><p>连通图的生成树是包含图中全部顶点的一个极小连通子图</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>无向图的全部顶点的度的和等于边数的2倍</p></li><li><p>有向图的全部顶点的入度等于全部顶点的出度（有向图顶点的度等于入度加出度）</p></li><li><p>边数与顶点数的关系：</p></li></ul><p>顶点太多，边太少会导致无法连通<br>顶点太少，边太多会导致有环产生<br>关键点： 顶点数 - 边数 &#x3D; 1 时 刚好可以做到连通且无环（注意不是一定：如（两个不连通的子图））<br>相较于此临界点若顶点数偏多则必不连通，相对于此临界点若边数偏多则必有环。  </p><ul><li><p>无向图的极大连通子图称为连通分量</p><ul><li>如果本身就是连通图 那么 本身就是其连通分量</li></ul></li><li><p>极小连通子图：保证了连通，又有最少的边数</p><ul><li>连通图的生成树是包含图中全部顶点的一个极小连通子图</li></ul></li><li><p><strong>（错误的）</strong> 图的遍历就是从图中某一顶点出发访遍图中其余顶点<strong>（错误的）</strong></p><ul><li>不准确，如果不是连通图，从某一顶点出发不可能能访问到任意顶点</li></ul></li><li><p>非连通图最极端情况是由一个完全图和一个独立的顶点构成，此时再加一条边，就<strong>（确保）</strong>构成了连通图</p></li><li><p>注意区分 “可以形成连通图的最少边数” 和 “保证形成连通图的最少边数” 的区别 前者n个顶点 n-1 条边即可 后者 n个顶点 $C_{n-1}^{2} +1$ 条边</p></li></ul><h1 id="图的存储以及基本操作"><a href="#图的存储以及基本操作" class="headerlink" title="图的存储以及基本操作"></a>图的存储以及基本操作</h1><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li><p>邻接多重表是无向图的存储结构</p></li><li><p>十字链表是有向图的存储结构</p></li></ul><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><table><thead><tr><th align="center"></th><th align="center">BFS(广度优先)</th><th align="center">DFS(深度优先)</th></tr></thead><tbody><tr><td align="center">空间复杂度</td><td align="center">O(丨V丨)<br>来自递归工作栈</td><td align="center">O(丨V丨)<br>来自辅助队列</td></tr><tr><td align="center">时间复杂度(邻接矩阵)<br>(邻接表)</td><td align="center">O(丨V丨<sup>2</sup>)<br>O(丨V丨+丨E丨)</td><td align="center">O(丨V丨<sup>2</sup>)<br>O(丨V丨+丨E丨)</td></tr></tbody></table><h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><ul><li><p>求最小生成树中<code>Prim算法</code>和<code>Kruskal算法</code>是基于贪心策略的，如果没有权值相同的边，那么寻找的过程没有分歧，是唯一的，最小生成树也一定唯一</p><ul><li>产生不同的最小生成树 的 充分不必要条件是 一定要有权值相同的边</li></ul></li><li><p>深度优先遍历和拓扑排序可以判断处一个<strong>有向图</strong>是否有环</p></li><li><p>在拓扑排序算法中为暂存入度为零的顶点，可以用栈，也可以用队列（数组也可以）。</p></li><li><p><strong>（错误）</strong>若有向图的拓扑有序序列唯一，则图中每个顶点的入度和出度最多为1（错误）</p><ul><li>反例 <img src="/2023/05/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-%E5%9B%BE/2023-05-15-22-55-50.png">a</li></ul></li><li><p>有向图邻接矩阵为三角矩阵且主对角元全为零的 充要条件 是该图可以进行拓扑排序 但不唯一</p></li><li><p>kruskal算法不用像prim算法一样 一定要把新选中的 纳入生成树 </p></li><li><p>将DFS算法 输出顶点信息移动的语句到退出递归（退栈）前，遍历有向无环图，输出的是逆拓扑序列</p><ul><li>按照DFS的规则，在遍历完该结点所有后继结点后才会出栈。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础-目录</title>
    <link href="/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%80%BB%E7%9B%AE%E5%BD%95/"/>
    <url>/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%80%BB%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><font size = 20><strong>知识点</strong>  </font></p><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><ul><li><a href="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/#%E6%8E%92%E5%BA%8F">排序</a></li><li><a href="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/#%E4%BA%8C%E5%88%86">二分</a></li><li><a href="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/#%E9%AB%98%E7%B2%BE%E5%BA%A6">高精度</a></li><li><a href="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/#%E5%89%8D%E7%BC%80%E5%92%8C">前缀和</a></li><li><a href="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/#%E5%B7%AE%E5%88%86">差分</a></li><li><a href="/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/#%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95">双指针算法</a></li><li><a href="/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/#%E4%BD%8D%E8%BF%90%E7%AE%97">位运算</a></li><li><a href="/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/#%E7%A6%BB%E6%95%A3%E5%8C%96">离散化</a></li><li><a href="/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6">区间合并</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础-1-基础算法（三）</title>
    <link href="/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ol><li>先想朴素(暴力)算法 </li><li>通过i与j的规律 将朴素算法O($n^{2} $) 优化到O(n)</li></ol><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>(简单)一段话按单词输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">gets</span>(str);<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n ;i++)&#123;<br>        <span class="hljs-type">int</span> j=i;<br>        <span class="hljs-keyword">while</span>(j&lt;n&amp;&amp;str[j]!=<span class="hljs-string">&#x27; &#x27;</span>) j++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i;k&lt;j;k++)    cout&lt;&lt;str[k];<br>        cout&lt;&lt;endl;<br>        i=j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h3><p><a href="https://www.acwing.com/problem/content/801/">最长连续不重复子序列</a><br><img src="/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/2023-05-07-14-42-25.png"></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n,res,a[N],s[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        s[a[i]]++;<br>        <span class="hljs-keyword">while</span>(s[a[i]]&gt;<span class="hljs-number">1</span>)        <span class="hljs-comment">//不用判断i&lt;j,因为在该题中一定成立</span><br>            s[a[j]]--,j++;<br>        res = <span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解题思想"><a href="#解题思想" class="headerlink" title="解题思想"></a>解题思想</h4><ul><li><p><code>i</code>:枚举  <code>j</code>:往左最远能到什么地方<br><code>j</code>有单调性 随着<code>i</code>向右走 <code>j</code>只会向右走or不走</p></li><li><p>检验子序列是否出现重复数 可用一个数组<code>s</code>,<code>i</code>每次右移 子序列加入一个数<code>a[i]</code> 数组对应数<code>s[a[i]]+1</code> ;<code>j</code>每次右移 子序列失去一个数<code>a[j]</code> 数组对应数<code>s[a[j]]-1</code>  </p><ul><li>若<code>i</code>右移 加入的数<code>a[i]</code>使得子序列出现重复数 重复的数一定是刚加入的数<code>a[i]</code> 此时<code>s[a[i]]&gt;1</code> 所有应该让<code>j</code>右移动 直到<code>s[a[i]]=1</code> 使得子序列无重复数</li></ul></li></ul><h3 id="数组元素的目标和"><a href="#数组元素的目标和" class="headerlink" title="数组元素的目标和"></a>数组元素的目标和</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>二进制表示中的第k位数字</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">3</span>;k&gt;=<span class="hljs-number">0</span>;k--)   cout&lt;&lt;(n&gt;&gt;k&amp;<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>求n的二进制表示中的第k位数字(从低位开始,第一位为0)：n &gt;&gt; k &amp; 1</p><ol><li>先把第k位移到最后一位：n &gt;&gt; k;</li><li>看个位是几: x &amp; 1</li></ol><h1 id="lowbit函数"><a href="#lowbit函数" class="headerlink" title="lowbit函数"></a>lowbit函数</h1><p><code>lowbit(n)</code>函数 返回n在二进制表示下最低位的1以及它后面的0构成的数值</p><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li><code>x&amp;(-x)=x&amp;(~x+1)</code> <ul><li><code>-x</code>是补码 <code>~x</code>是反码</li></ul></li><li>理解:<br>  -已知求补码的的快捷方法:对原码从右往左数,直到遇到第一个数字1,1及1右边的0不变,1左边的数字按位取反  所以<code>x&amp;(-x)</code>只会得到最低位1及右边的0构成的数值,最低位1左边的数&amp;运算后全为0</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>最简单的一个应用————统计二进制中1的个数<br>例题:<br><a href="https://www.acwing.com/problem/content/803/">二进制中1的个数</a><br><img src="/2023/05/07/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/2023-05-07-16-53-01.png"></p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(q[i])&#123;<br>            q[i]-=<span class="hljs-built_in">lowbit</span>(q[i]);<br>            j++;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,j);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DB基础学习笔记</title>
    <link href="/2023/05/06/DB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/05/06/DB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>SQL 分类</p><table><thead><tr><th>分类</th><th>全称</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td></tr><tr><td>DML</td><td>Data Manipulation</td></tr><tr><td>DQL</td><td>Data Query Language</td></tr><tr><td>DCL</td><td>Data Control Language</td></tr></tbody></table><h2 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询所有数据库</span><br><span class="hljs-keyword">show</span> databases;<br><br><span class="hljs-comment">-- 查询当前数据库</span><br><span class="hljs-keyword">select</span> database();<br><br><span class="hljs-comment">-- 创建数据库</span><br><span class="hljs-keyword">create</span> database if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> info ;<br><br><span class="hljs-comment">-- 删除数据库</span><br><span class="hljs-keyword">drop</span> database if <span class="hljs-keyword">exists</span> info;<br><br><span class="hljs-comment">-- 切换数据库</span><br>use info ;<br></code></pre></td></tr></table></figure><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询当前数据库所有表</span><br><span class="hljs-keyword">show</span> tables ;<br><br><span class="hljs-comment">-- 查看指定表结构</span><br><span class="hljs-keyword">desc</span> course;<br><br><span class="hljs-comment">-- 查询指定表的建表语句</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> course;<br><br><span class="hljs-comment">-- 创建表结构</span><br><span class="hljs-comment">-- CREATE TABLE 表名(</span><br><span class="hljs-comment">-- 字段1 字段1类型 [ COMMENT 字段1注释 ],</span><br><span class="hljs-comment">-- 字段2 字段2类型 [COMMENT 字段2注释 ],</span><br><span class="hljs-comment">-- 字段3 字段3类型 [COMMENT 字段3注释 ],</span><br><span class="hljs-comment">-- ......</span><br><span class="hljs-comment">-- 字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="hljs-comment">-- ) [ COMMENT 表注释 ] ;</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user(<br>                        id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>                        name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>                        age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>                        gender <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span><br>) comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>                    id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>                    workno <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;工号&#x27;</span>,<br>                    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>                    gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span>,<br>                    age tinyint unsigned comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>                    idcard <span class="hljs-type">char</span>(<span class="hljs-number">18</span>) comment <span class="hljs-string">&#x27;身份证号&#x27;</span>,<br>                    entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span><br>) comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><br><span class="hljs-comment">-- 表操作----&gt;修改</span><br><span class="hljs-comment">-- 1.添加字段</span><br><span class="hljs-comment">-- ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> emp <span class="hljs-keyword">ADD</span> nickname <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) COMMENT <span class="hljs-string">&#x27;昵称&#x27;</span>;<br><span class="hljs-comment">-- 2.修改数据类型</span><br><span class="hljs-comment">-- ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度);</span><br><span class="hljs-comment">-- 3.修改字段名和字段类型</span><br><span class="hljs-comment">-- ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> emp CHANGE nickname username <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) COMMENT <span class="hljs-string">&#x27;昵称&#x27;</span>;<br><span class="hljs-comment">-- 4.删除字段</span><br><span class="hljs-comment">-- ALTER TABLE 表名 DROP 字段名;</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> emp <span class="hljs-keyword">DROP</span> username;<br><span class="hljs-comment">-- 5.修改表明</span><br><span class="hljs-comment">-- ALTER TABLE 表名 RENAME TO 新表名;</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> emp RENAME <span class="hljs-keyword">TO</span> employee;<br><span class="hljs-comment">-- 表操作----&gt;删除</span><br><span class="hljs-comment">-- 1.删除表</span><br><span class="hljs-comment">-- DROP TABLE [ IF EXISTS ] 表名;</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> tb_user;<br><span class="hljs-comment">-- 2.删除指定表，并重新创建表</span><br><span class="hljs-comment">-- TRUNCATE TABLE 表名;</span><br></code></pre></td></tr></table></figure><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 添加数据</span><br><span class="hljs-comment">-- 1.给指定字段添加数据</span><br><span class="hljs-comment">-- INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> employee(id,workno,name,gender,age,idcard,entrydate)<br><span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;Itcast&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;123456789012345678&#x27;</span>,<span class="hljs-string">&#x27;2000-01-01&#x27;</span>);<br><span class="hljs-comment">-- 2.给全部字段添加数据</span><br><span class="hljs-comment">-- INSERT INTO 表名 VALUES (值1, 值2, ...);</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> employee <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;张无忌&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;123456789012345670&#x27;</span>,<span class="hljs-string">&#x27;2005-01-01&#x27;</span>);<br><span class="hljs-comment">-- 3.批量添加数据</span><br><span class="hljs-comment">-- INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</span><br><span class="hljs-comment">-- INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> employee <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;韦一笑&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">38</span>,<span class="hljs-string">&#x27;123456789012345670&#x27;</span>,<span class="hljs-string">&#x27;2005-01-01&#x27;</span>),(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;赵敏&#x27;</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;123456789012345670&#x27;</span>,<span class="hljs-string">&#x27;2005-01-01&#x27;</span>);<br><br><span class="hljs-comment">-- 修改数据</span><br><span class="hljs-comment">-- UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;</span><br><span class="hljs-keyword">update</span> employee <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;itheima&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">update</span> employee <span class="hljs-keyword">set</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;小昭&#x27;</span> , gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">update</span> employee <span class="hljs-keyword">set</span> entrydate <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2008-01-01&#x27;</span>;<br><br><span class="hljs-comment">-- 删除数据</span><br><span class="hljs-comment">-- DELETE FROM 表名 [ WHERE 条件 ] ;</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span>;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> employee;<br></code></pre></td></tr></table></figure><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    字段列表<br><span class="hljs-keyword">FROM</span><br>    表名列表<br><span class="hljs-keyword">WHERE</span><br>    条件列表<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>    分组字段列表<br><span class="hljs-keyword">HAVING</span><br>    分组后条件列表<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>    排序字段列表<br>LIMIT<br>    分页参数<br></code></pre></td></tr></table></figure><hr><p>准备工作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 准备工作</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> employee;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>                    id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>                    workno <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;工号&#x27;</span>,<br>                    name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>                    gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span>,<br>                    age tinyint unsigned comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>                    idcard <span class="hljs-type">char</span>(<span class="hljs-number">18</span>) comment <span class="hljs-string">&#x27;身份证号&#x27;</span>,<br>                    workaddress <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) comment <span class="hljs-string">&#x27;工作地址&#x27;</span>,<br>                    entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span><br>)comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;00001&#x27;</span>, <span class="hljs-string">&#x27;柳岩666&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;123456789012345678&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;00002&#x27;</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2005-09-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;00003&#x27;</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;123456789712345670&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;2005-08-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;00004&#x27;</span>, <span class="hljs-string">&#x27;赵敏&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;123456757123845670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2009-12-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;00005&#x27;</span>, <span class="hljs-string">&#x27;小昭&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&#x27;123456769012345678&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;2007-07-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;00006&#x27;</span>, <span class="hljs-string">&#x27;杨逍&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;12345678931234567X&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2006-01-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;00007&#x27;</span>, <span class="hljs-string">&#x27;范瑶&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&#x27;123456789212345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2005-05-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;00008&#x27;</span>, <span class="hljs-string">&#x27;黛绮丝&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;123456157123645670&#x27;</span>, <span class="hljs-string">&#x27;天津&#x27;</span>, <span class="hljs-string">&#x27;2015-05-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;00009&#x27;</span>, <span class="hljs-string">&#x27;范凉凉&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;123156789012345678&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2010-04-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;00010&#x27;</span>, <span class="hljs-string">&#x27;陈友谅&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">53</span>, <span class="hljs-string">&#x27;123456789012345670&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;2011-01-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;00011&#x27;</span>, <span class="hljs-string">&#x27;张士诚&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">55</span>, <span class="hljs-string">&#x27;123567897123465670&#x27;</span>, <span class="hljs-string">&#x27;江苏&#x27;</span>, <span class="hljs-string">&#x27;2015-05-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;00012&#x27;</span>, <span class="hljs-string">&#x27;常遇春&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;123446757152345670&#x27;</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2004-02-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;00013&#x27;</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;123656789012345678&#x27;</span>, <span class="hljs-string">&#x27;江苏&#x27;</span>, <span class="hljs-string">&#x27;2020-11-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">14</span>, <span class="hljs-string">&#x27;00014&#x27;</span>, <span class="hljs-string">&#x27;灭绝&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">65</span>, <span class="hljs-string">&#x27;123456719012345670&#x27;</span>, <span class="hljs-string">&#x27;西安&#x27;</span>, <span class="hljs-string">&#x27;2019-05-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;00015&#x27;</span>, <span class="hljs-string">&#x27;胡青牛&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">70</span>, <span class="hljs-string">&#x27;12345674971234567X&#x27;</span>, <span class="hljs-string">&#x27;西安&#x27;</span>, <span class="hljs-string">&#x27;2018-04-01&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, workno, name, gender, age, idcard, workaddress, entrydate)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;00016&#x27;</span>, <span class="hljs-string">&#x27;周芷若&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;2012-06-01&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 基础查询</span><br><span class="hljs-comment">-- 1.查询多个字段</span><br><span class="hljs-comment">-- SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;</span><br><span class="hljs-comment">-- SELECT * FROM 表名 ;</span><br><span class="hljs-comment">-- 2.字段设置别名</span><br><span class="hljs-comment">-- SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;</span><br><span class="hljs-comment">-- SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</span><br><span class="hljs-comment">-- 3.去除重复记录</span><br><span class="hljs-comment">-- SELECT DISTINCT 字段列表 FROM 表名;</span><br><span class="hljs-keyword">select</span> name,workno,age <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> id ,workno,name,gender,age,idcard,workaddress,entrydate <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> workaddress <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;工作地址&#x27;</span> <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> workaddress <span class="hljs-string">&#x27;工作地址&#x27;</span> <span class="hljs-keyword">from</span> emp;<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> workaddress <span class="hljs-string">&#x27;工作地址&#x27;</span> <span class="hljs-keyword">from</span> emp;<br></code></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 条件查询</span><br><span class="hljs-comment">-- 1.语法</span><br><span class="hljs-comment">-- SELECT 字段列表 FROM 表名 WHERE 条件列表 ;</span><br><span class="hljs-comment">-- 2.条件</span><br><span class="hljs-comment">-- BETWEEN ... AND ...  在某个范围之内(含最小、最大值)</span><br><span class="hljs-comment">-- IN(...)              在in之后的列表中的值，多选一</span><br><span class="hljs-comment">-- LIKE 占位符           模糊匹配(_匹配单个字符, %匹配任意个字符)</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">88</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">!=</span> <span class="hljs-number">88</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">88</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">15</span> <span class="hljs-operator">&amp;&amp;</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">15</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">15</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">25</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span><span class="hljs-number">40</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-keyword">in</span>(<span class="hljs-number">18</span>,<span class="hljs-number">20</span>,<span class="hljs-number">40</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;__&#x27;</span>; <span class="hljs-comment">-- 查询姓名为两个字的员工信息 _ %</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%X&#x27;</span>;   <span class="hljs-comment">-- 查询身份证号最后一位是X的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> idcard <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;_________________X&#x27;</span>; <span class="hljs-comment">-- 查询身份证号最后一位是X的员工信息</span><br></code></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 分组查询</span><br><span class="hljs-comment">-- 语法</span><br><span class="hljs-comment">-- SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];</span><br><span class="hljs-comment">-- where与having区别</span><br><span class="hljs-comment">-- 1.执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</span><br><span class="hljs-comment">-- 2.判断条件不同：where不能对聚合函数进行判断，而having可以。</span><br><span class="hljs-comment">-- 注意事项</span><br><span class="hljs-comment">-- 1.分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</span><br><span class="hljs-comment">-- 2.执行顺序: where &gt; 聚合函数 &gt; having 。</span><br><span class="hljs-comment">-- 3.支持多字段分组, 具体语法为 : group by columnA,columnB</span><br><span class="hljs-comment">-- 4.一般查询的字段是分组之后的字段和聚合函数字段</span><br><span class="hljs-keyword">select</span> gender, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender ; <span class="hljs-comment">-- 根据性别分组 , 统计男性员工 和 女性员工的数量</span><br><span class="hljs-keyword">select</span> gender, <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender ; <span class="hljs-comment">-- 根据性别分组 , 统计男性员工 和 女性员工的平均年龄</span><br><span class="hljs-keyword">select</span> workaddress, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) address_count <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>    workaddress <span class="hljs-keyword">having</span> address_count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>; <span class="hljs-comment">-- 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</span><br><span class="hljs-keyword">select</span> workaddress, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) 员工数 <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">45</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span><br>    workaddress <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">select</span> workaddress, gender, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-string">&#x27;数量&#x27;</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender , workaddress; <span class="hljs-comment">-- 统计各个工作地址上班的男性及女性员工的数量</span><br></code></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 排序查询</span><br><span class="hljs-comment">-- 语法</span><br><span class="hljs-comment">-- SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;</span><br><span class="hljs-comment">-- 排序方式 ASC : 升序(默认值)  DESC: 降序</span><br><span class="hljs-comment">-- 如果是升序, 可以不指定排序方式ASC ;</span><br><span class="hljs-comment">-- 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span>; <span class="hljs-comment">--  根据年龄对公司的员工进行升序排序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;     <span class="hljs-comment">--  根据年龄对公司的员工进行升序排序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> entrydate <span class="hljs-keyword">desc</span>; <span class="hljs-comment">-- 根据入职时间, 对员工进行降序排序</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> , entrydate <span class="hljs-keyword">desc</span>;    <span class="hljs-comment">-- 根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序</span><br></code></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 分页查询</span><br><span class="hljs-comment">-- 语法</span><br><span class="hljs-comment">-- SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</span><br><span class="hljs-comment">-- 注意事项</span><br><span class="hljs-comment">-- 起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。</span><br><span class="hljs-comment">-- 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。</span><br><span class="hljs-comment">-- 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span>; <span class="hljs-comment">-- 查询第1页员工数据, 每页展示10条记录</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">10</span>;   <span class="hljs-comment">-- 查询第1页员工数据, 每页展示10条记录</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp limit <span class="hljs-number">10</span>,<span class="hljs-number">10</span>; <span class="hljs-comment">--  查询第2页员工数据, 每页展示10条记录 --------&gt; (页码-1)*页展示记录数</span><br><br></code></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 案例</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;女&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-keyword">in</span>(<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>);  <span class="hljs-comment">-- 查询年龄为20,21,22,23岁的女员工信息。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">and</span> ( age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">40</span> ) <span class="hljs-keyword">and</span> name <span class="hljs-keyword">like</span><span class="hljs-string">&#x27;___&#x27;</span>;  <span class="hljs-comment">-- 查询性别为 男 ，并且年龄在 20-40 岁(含)以内的姓名为三个字的员工。</span><br><span class="hljs-keyword">select</span> gender, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender;  <span class="hljs-comment">-- 统计员工表中, 年龄小于60岁的 , 男性员工和女性员工的人数。</span><br><span class="hljs-keyword">select</span> name , age <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">35</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> , entrydate <span class="hljs-keyword">desc</span>; <span class="hljs-comment">-- 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">40</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> ,entrydate <span class="hljs-keyword">asc</span> limit <span class="hljs-number">5</span> ; <span class="hljs-comment">-- 查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序。</span><br></code></pre></td></tr></table></figure><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>DQL语句的执行顺序为：<br><code>from</code> … <code>where</code> … <code>group by</code> … <code>having</code> … <code>select</code> … <code>order by</code> … <code>limit</code> …</p><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询用户</span><br><span class="hljs-comment">-- select * from mysql.user;</span><br><span class="hljs-comment">-- 创建用户</span><br><span class="hljs-comment">-- CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br><span class="hljs-comment">-- 修改用户密码</span><br><span class="hljs-comment">-- ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27; ;</span><br><span class="hljs-comment">-- 删除用户</span><br><span class="hljs-comment">-- DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27; ;</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;itcast&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>; <span class="hljs-comment">-- 创建用户itcast, 只能够在当前主机localhost访问, 密码123456;</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;heima&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>; <span class="hljs-comment">--  创建用户heima, 可以在任意主机访问该数据库, 密码123456;</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;heima&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;1234&#x27;</span>;<span class="hljs-comment">-- 修改用户heima的访问密码为1234;</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;itcast&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>; <span class="hljs-comment">-- 删除 itcast@localhost 用户</span><br></code></pre></td></tr></table></figure><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><table><thead><tr><th align="center">权限</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ALL, ALL PRIVILEGES</td><td align="center">所有权限</td></tr><tr><td align="center">SELECT</td><td align="center">查询数据</td></tr><tr><td align="center">INSERT</td><td align="center">插入数据</td></tr><tr><td align="center">UPDATE</td><td align="center">修改数据</td></tr><tr><td align="center">DELETE</td><td align="center">删除数据</td></tr><tr><td align="center">ALTER</td><td align="center">修改表</td></tr><tr><td align="center">DROP</td><td align="center">删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td align="center">CREATE</td><td align="center">创建数据库&#x2F;表</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-comment">-- 查询权限</span><br><span class="hljs-comment">-- SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; ;</span><br><span class="hljs-comment">-- 授予权限</span><br><span class="hljs-comment">-- GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="hljs-comment">-- 撤销权限</span><br><span class="hljs-comment">-- REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br><span class="hljs-keyword">show</span> grants <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;heima&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>; <span class="hljs-comment">-- 查询 &#x27;heima&#x27;@&#x27;%&#x27; 用户的权限</span><br><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> itcast.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;heima&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>; <span class="hljs-comment">-- 授予 &#x27;heima&#x27;@&#x27;%&#x27; 用户itcast数据库所有表的所有操作权限</span><br><span class="hljs-keyword">revoke</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> itcast.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;heima&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>; <span class="hljs-comment">-- 撤销 &#x27;heima&#x27;@&#x27;%&#x27; 用户的itcast数据库的所有权限</span><br><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>常用如下：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…Sn)</td><td>字符串拼接，将S1，S2，… Sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str,start,len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;Hello&#x27;</span> , <span class="hljs-string">&#x27; MySQL&#x27;</span>); <span class="hljs-comment">-- concat : 字符串拼接</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">lower</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>); <span class="hljs-comment">-- lower : 全部转小写</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>); <span class="hljs-comment">-- upper : 全部转大写</span><br><span class="hljs-keyword">select</span> lpad(<span class="hljs-string">&#x27;01&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">-- lpad : 左填充</span><br><span class="hljs-keyword">select</span> rpad(<span class="hljs-string">&#x27;01&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">-- rpad : 右填充</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27; Hello MySQL &#x27;</span>); <span class="hljs-comment">-- trim : 去除空格</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;Hello MySQL&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">-- substring : 截取子字符串</span><br><span class="hljs-comment">-- 案例</span><br><span class="hljs-keyword">update</span> emp <span class="hljs-keyword">set</span> workno <span class="hljs-operator">=</span> lpad(workno, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">-- 由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员工的工号应该为00001。</span><br></code></pre></td></tr></table></figure><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><p>常用如下：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x&#x2F;y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.1</span>); <span class="hljs-comment">-- ceil：向上取整</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">1.9</span>); <span class="hljs-comment">-- floor：向下取整</span><br><span class="hljs-keyword">select</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">--  mod：取模</span><br><span class="hljs-keyword">select</span> rand(); <span class="hljs-comment">-- rand：获取随机数</span><br><span class="hljs-keyword">select</span> round(<span class="hljs-number">2.344</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">-- round：四舍五入</span><br><span class="hljs-comment">--案例</span><br><span class="hljs-keyword">select</span> lpad(round(rand()<span class="hljs-operator">*</span><span class="hljs-number">1000000</span> , <span class="hljs-number">0</span>), <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">-- 通过数据库的函数，生成一个六位数的随机验证码。</span><br></code></pre></td></tr></table></figure><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p>常用如下：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL exprtype)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间date1 和 结束时间date2之间的天数</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> curdate(); <span class="hljs-comment">-- curdate：当前日期</span><br><span class="hljs-keyword">select</span> curtime(); <span class="hljs-comment">-- curtime：当前时间</span><br><span class="hljs-keyword">select</span> now(); <span class="hljs-comment">-- now：当前日期和时间</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">YEAR</span>(now()); <span class="hljs-comment">-- 当前年</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">MONTH</span>(now()); <span class="hljs-comment">-- 当前月</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">DAY</span>(now()); <span class="hljs-comment">-- 当前日</span><br><span class="hljs-keyword">select</span> date_add(now(), <span class="hljs-type">INTERVAL</span> <span class="hljs-number">70</span> <span class="hljs-keyword">YEAR</span> ); <span class="hljs-comment">-- date_add：增加指定的时间间隔</span><br><span class="hljs-keyword">select</span> datediff(<span class="hljs-string">&#x27;2021-10-01&#x27;</span>, <span class="hljs-string">&#x27;2021-12-01&#x27;</span>); <span class="hljs-comment">-- datediff：获取两个日期相差的天数</span><br><span class="hljs-comment">-- 案例</span><br><span class="hljs-comment">-- 查询所有员工的入职天数，并根据入职天数倒序排序。</span><br><span class="hljs-keyword">select</span> name,datediff(curdate(),entrydate) <span class="hljs-keyword">as</span> 入职天数 <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 入职天数 <span class="hljs-keyword">desc</span>;<br></code></pre></td></tr></table></figure><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value , t , f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1 , value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [res1] …ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ]</td><td>END如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- if</span><br><span class="hljs-keyword">select</span> if(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;Ok&#x27;</span>, <span class="hljs-string">&#x27;Error&#x27;</span>);<br><span class="hljs-comment">-- ifnull</span><br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-string">&#x27;Ok&#x27;</span>,<span class="hljs-string">&#x27;Default&#x27;</span>);<br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;Default&#x27;</span>);<br><span class="hljs-keyword">select</span> ifnull(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Default&#x27;</span>);<br><span class="hljs-comment">-- case when then else end</span><br><span class="hljs-comment">-- 需求: 查询emp表的员工姓名和工作地址 (北京/上海 ----&gt; 一线城市 , 其他 ----&gt; 二线城市)</span><br><span class="hljs-keyword">select</span><br>    name,<br>    ( <span class="hljs-keyword">case</span> workaddress <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;北京&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;一线城市&#x27;</span> <span class="hljs-keyword">when</span> <span class="hljs-string">&#x27;上海&#x27;</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;一线城市&#x27;</span> <span class="hljs-keyword">else</span><br>        <span class="hljs-string">&#x27;二线城市&#x27;</span> <span class="hljs-keyword">end</span> ) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;工作地址&#x27;</span><br><span class="hljs-keyword">from</span> emp;<br><br></code></pre></td></tr></table></figure><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>作用于表中字段上的规则，用于限制存储在表中的数据，保证数据库中数据的正确、有效性和完整性<br>分类：</p><table><thead><tr><th align="center">约束</th><th align="center">描述</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">非空约束</td><td align="center">限制该字段的数据不能为null</td><td align="center">NOT NULL</td></tr><tr><td align="center">唯一约束</td><td align="center">保证该字段的所有数据都是唯一、不重复的</td><td align="center">UNIQUE</td></tr><tr><td align="center">主键约束</td><td align="center">主键是一行数据的唯一标识，要求非空且唯一</td><td align="center">PRIMARY KEY</td></tr><tr><td align="center">默认约束</td><td align="center">保存数据时，如果未指定该字段的值，则采用默认值</td><td align="center">DEFAULT</td></tr><tr><td align="center">检查约束(8.0.16版本之后)</td><td align="center">保证字段值满足某一个条件</td><td align="center">CHECK</td></tr><tr><td align="center">外键约束</td><td align="center">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td align="center">FOREIGN KEY</td></tr></tbody></table><p>注意：约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tb_user(<br>                        id <span class="hljs-type">int</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY COMMENT <span class="hljs-string">&#x27;ID唯一标识&#x27;</span>,<br>                        name <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span> ,<br>                        age <span class="hljs-type">int</span> <span class="hljs-keyword">check</span> (age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">120</span>) COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span> ,<br>                        status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span> COMMENT <span class="hljs-string">&#x27;状态&#x27;</span>,<br>                        gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>) COMMENT <span class="hljs-string">&#x27;性别&#x27;</span><br>);<br></code></pre></td></tr></table></figure><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性<br>表(子表)的外键是关联另一张表(父表)的主键</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol><li>添加外键<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>    字段名 数据类型,<br>    ...<br>    [<span class="hljs-keyword">CONSTRAINT</span>] [外键名称] <span class="hljs-keyword">FOREIGN</span> KEY (外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表 (主表列名)<br>);<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表 (主表列名) ;<br>```  <br><br>案例:<br>```<span class="hljs-keyword">sql</span><br><span class="hljs-comment">-- 案例：为emp表的dept_id字段添加外键约束,关联dept表的主键id。</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span> dept(id);<br></code></pre></td></tr></table></figure><ol start="2"><li>删除外键<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY 外键名称;<br></code></pre></td></tr></table></figure></li></ol><p>案例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 案例：删除emp表的外键fk_emp_dept_id</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">drop</span> <span class="hljs-keyword">foreign</span> key fk_emp_dept_id;<br></code></pre></td></tr></table></figure><h3 id="删除更新行为"><a href="#删除更新行为" class="headerlink" title="删除更新行为"></a>删除更新行为</h3><p>添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除&#x2F;更新行为。具体的删除&#x2F;更新行为有以下几种:</p><table><thead><tr><th align="center">行为</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NO ACTION</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 (与 RESTRICT 一致) 默认行为</td></tr><tr><td align="center">RESTRICT</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。 (与 NO ACTION 一致) 默认行为</td></tr><tr><td align="center">CASCADE</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除&#x2F;更新外键在子表中的记录。</td></tr><tr><td align="center">SET NULL</td><td align="center">当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（这就要求该外键允许取null）。</td></tr><tr><td align="center">SET DEFAULT</td><td align="center">父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td></tr></tbody></table><p>具体语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> KEY (外键字段) <span class="hljs-keyword">REFERENCES</span> 主表名 (主表字段名) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE;<br></code></pre></td></tr></table></figure><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>准备工作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> emp;<br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> dept;<br><span class="hljs-comment">-- 创建dept表，并插入数据</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept(<br>                     id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>                     name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;部门名称&#x27;</span><br>)comment <span class="hljs-string">&#x27;部门表&#x27;</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept (id, name) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;研发部&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;市场部&#x27;</span>),(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;财务部&#x27;</span>), (<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;销售部&#x27;</span>), (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;总经办&#x27;</span>), (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;人事部&#x27;</span>);<br><span class="hljs-comment">-- 创建emp表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> emp(<br>                    id <span class="hljs-type">int</span> auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span> <span class="hljs-keyword">primary</span> key,<br>                    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>                    age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>                    job <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) comment <span class="hljs-string">&#x27;职位&#x27;</span>,<br>                    salary <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;薪资&#x27;</span>,<br>                    entrydate <span class="hljs-type">date</span> comment <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br>                    managerid <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;直属领导ID&#x27;</span>,<br>                    dept_id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;部门ID&#x27;</span><br>)comment <span class="hljs-string">&#x27;员工表&#x27;</span>;<br><span class="hljs-comment">-- 添加外键</span><br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> emp <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> fk_emp_dept_id <span class="hljs-keyword">foreign</span> key (dept_id) <span class="hljs-keyword">references</span> dept(id);<br><span class="hljs-comment">-- 插入数据</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp (id, name, age, job,salary, entrydate, managerid, dept_id)<br><span class="hljs-keyword">VALUES</span><br>    (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;金庸&#x27;</span>, <span class="hljs-number">66</span>, <span class="hljs-string">&#x27;总裁&#x27;</span>,<span class="hljs-number">20000</span>, <span class="hljs-string">&#x27;2000-01-01&#x27;</span>, <span class="hljs-keyword">null</span>,<span class="hljs-number">5</span>),<br>    (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;张无忌&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;项目经理&#x27;</span>,<span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2005-12-05&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;杨逍&#x27;</span>, <span class="hljs-number">33</span>, <span class="hljs-string">&#x27;开发&#x27;</span>, <span class="hljs-number">8400</span>,<span class="hljs-string">&#x27;2000-11-03&#x27;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;韦一笑&#x27;</span>, <span class="hljs-number">48</span>, <span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">11000</span>, <span class="hljs-string">&#x27;2002-02-05&#x27;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;常遇春&#x27;</span>, <span class="hljs-number">43</span>, <span class="hljs-string">&#x27;开发&#x27;</span>,<span class="hljs-number">10500</span>, <span class="hljs-string">&#x27;2004-09-07&#x27;</span>, <span class="hljs-number">3</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;小昭&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;程序员鼓励师&#x27;</span>,<span class="hljs-number">6600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">2</span>,<span class="hljs-number">1</span>),<br>    (<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;灭绝&#x27;</span>, <span class="hljs-number">60</span>, <span class="hljs-string">&#x27;财务总监&#x27;</span>,<span class="hljs-number">8500</span>, <span class="hljs-string">&#x27;2002-09-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">3</span>),<br>    (<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;周芷若&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;会计&#x27;</span>,<span class="hljs-number">48000</span>, <span class="hljs-string">&#x27;2006-06-02&#x27;</span>, <span class="hljs-number">7</span>,<span class="hljs-number">3</span>),<br>    (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;丁敏君&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;出纳&#x27;</span>,<span class="hljs-number">5250</span>, <span class="hljs-string">&#x27;2009-05-13&#x27;</span>, <span class="hljs-number">7</span>,<span class="hljs-number">3</span>),<br>    (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;赵敏&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;市场部总监&#x27;</span>,<span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>),<br>    (<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;鹿杖客&#x27;</span>, <span class="hljs-number">56</span>, <span class="hljs-string">&#x27;职员&#x27;</span>,<span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2006-10-03&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>    (<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;鹤笔翁&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>,<span class="hljs-number">3750</span>, <span class="hljs-string">&#x27;2007-05-09&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>    (<span class="hljs-number">13</span>, <span class="hljs-string">&#x27;方东白&#x27;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&#x27;职员&#x27;</span>,<span class="hljs-number">5500</span>, <span class="hljs-string">&#x27;2009-02-12&#x27;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>    (<span class="hljs-number">14</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">88</span>, <span class="hljs-string">&#x27;销售总监&#x27;</span>,<span class="hljs-number">14000</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">4</span>),<br>    (<span class="hljs-number">15</span>, <span class="hljs-string">&#x27;俞莲舟&#x27;</span>, <span class="hljs-number">38</span>, <span class="hljs-string">&#x27;销售&#x27;</span>,<span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>,<span class="hljs-number">4</span>),<br>    (<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;宋远桥&#x27;</span>, <span class="hljs-number">40</span>, <span class="hljs-string">&#x27;销售&#x27;</span>,<span class="hljs-number">4600</span>, <span class="hljs-string">&#x27;2004-10-12&#x27;</span>, <span class="hljs-number">14</span>,<span class="hljs-number">4</span>),<br>    (<span class="hljs-number">17</span>, <span class="hljs-string">&#x27;陈友谅&#x27;</span>, <span class="hljs-number">42</span>, <span class="hljs-keyword">null</span>,<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;2011-10-12&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><h2 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h2><ul><li>连接查询<ul><li>内连接：相当于查询A、B交集部分数据</li><li>外连接：<ul><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ul></li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li><li>子查询</li></ul><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>内连接查询的是两张表交集部分的数据。<br>内连接：相当于左连接与右连接的合并，去掉所有含NULL的数据行，剩下的就是查询出来的数据了。其实就是两边的表都必须满足条件。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>内连接的语法分为两种: 隐式内连接、显式内连接。</p><ol><li>隐式内连接<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> , 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件 ... ;<br></code></pre></td></tr></table></figure></li><li>显示外连接<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [ <span class="hljs-keyword">INNER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件 ... ;<br></code></pre></td></tr></table></figure>相对而言，隐式连接好理解好书写，语法简单，担心的点较少。但是显式连接可以减少字段的扫描，有更快的执行速度。</li></ol><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><ol><li>查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)<br> 表结构: emp , dept<br> 连接条件: emp.dept_id &#x3D; dept.id<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> emp.name , dept.name <span class="hljs-keyword">from</span> emp , dept <span class="hljs-keyword">where</span> emp.dept_id <span class="hljs-operator">=</span> dept.id ;<br><span class="hljs-comment">-- 为每一张表起别名,简化SQL编写</span><br><span class="hljs-keyword">select</span> e.name,d.name <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">as</span> e , dept <span class="hljs-keyword">as</span> d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure></li><li>查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) — INNER JOIN … ON …<br> 表结构: emp , dept<br> 连接条件: emp.dept_id &#x3D; dept.id</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.name, d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><span class="hljs-comment">-- 为每一张表起别名,简化SQL编写</span><br><span class="hljs-keyword">select</span> e.name, d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><p><strong>表的别名</strong></p><ol><li><code>tablea as 别名1 , tableb as 别名2 ;</code></li><li><code>tablea 别名1 , tableb 别名2 ;</code></li></ol><ul><li>注意: 一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。</li></ul><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>外连接分为两种，分别是：左外连接 和 右外连接。<br>左连接：在 LEFT JOIN 左边的表里面数据全被全部查出来，右边的数据只会查出符合ON后面的符合条件的数据，不符合的会用NULL代替。<br>右连接：与 LEFT JOIN 正好相反，右边的数据会会全部查出来，左边只会查出ON后面符合条件的数据，不符合的会用NULL代替。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><ol><li>左外连接——相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [ <span class="hljs-keyword">OUTER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure></li><li>右外连接——右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [ <span class="hljs-keyword">OUTER</span> ] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure></li></ol><ul><li>注意:左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。</li></ul><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><ol><li>查询emp表的所有数据, 和对应的部门信息<br> 由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。<br> 表结构: emp, dept<br> 连接条件: emp.dept_id &#x3D; dept.id</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><ol start="2"><li>查询dept表的所有数据, 和对应的员工信息(右外连接)<br> 由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。<br> 表结构: emp, dept<br> 连接条件: emp.dept_id &#x3D; dept.id</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> d.<span class="hljs-operator">*</span>, e.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><span class="hljs-keyword">select</span> d.<span class="hljs-operator">*</span>, e.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> dept d <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> emp e <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><h3 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A 别名A <span class="hljs-keyword">JOIN</span> 表A 别名B <span class="hljs-keyword">ON</span> 条件 ... ;<br></code></pre></td></tr></table></figure><h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h4><ol><li>查询员工 及其 所属领导的名字<br> 表结构: emp</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.name , b.name <span class="hljs-keyword">from</span> emp a , emp b <span class="hljs-keyword">where</span> a.managerid <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><ol start="2"><li>查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来<br> 表结构: emp a , emp b</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a.name <span class="hljs-string">&#x27;员工&#x27;</span>, b.name <span class="hljs-string">&#x27;领导&#x27;</span> <span class="hljs-keyword">from</span> emp a <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp b <span class="hljs-keyword">on</span> a.managerid <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A ...<br><span class="hljs-keyword">UNION</span> [ <span class="hljs-keyword">ALL</span> ]<br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表B ....;<br></code></pre></td></tr></table></figure><ul><li><strong>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</strong></li><li><code>union all</code> 会将全部的数据直接<strong>合并在一起</strong>，<code>union</code> 会对合并之后的<strong>数据去重</strong>。</li></ul><h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h4><ol><li>将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来.<br>当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们也可以通过union&#x2F;union all来联合查询.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&lt;</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span>;<br><span class="hljs-comment">-- union all查询出来的结果，仅仅进行简单的合并，并未去重。</span><br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&lt;</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span>;<br><span class="hljs-comment">-- union 联合查询，会对查询出来的结果进行去重处理。</span><br></code></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> column1 <span class="hljs-operator">=</span> ( <span class="hljs-keyword">SELECT</span> column1 <span class="hljs-keyword">FROM</span> t2 );<br></code></pre></td></tr></table></figure><p>子查询外部的语句可以是<code>INSERT</code>  <code>UPDATE</code>  <code>DELETE</code>  <code>SELECT</code> 的任何一个。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据子查询结果不同，分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询(子查询结果为一列)</li><li>行子查询(子查询结果为一行)</li><li>表子查询(子查询结果为多行多列)</li></ul><p>根据子查询位置，分为：</p><ul><li>WHERE之后</li><li>FROM之后</li><li>SELECT之后</li></ul><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。<br>常用的操作符：<code>=</code> <code>&lt;&gt;</code> <code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></p><h4 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h4><ul><li>查询 “销售部” 的所有员工信息</li></ul><p>完成这个需求时，我们可以将需求分解为两步：</p><ol><li>查询 “销售部” 部门ID</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>根据 “销售部” 部门ID, 查询员工信息</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>查询在 “方东白” 入职之后的员工信息</li></ul><p>完成这个需求时，我们可以将需求分解为两步：</p><ol><li>查询 方东白 的入职日期</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> entrydate <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;方东白&#x27;</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>查询指定入职日期之后入职的员工信息</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> entrydate <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;方东白&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。<br>常用的操作符：<code>IN</code> 、<code>NOT IN</code> 、 <code>ANY</code> 、<code>SOME</code> 、 <code>ALL</code>  </p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IN</td><td align="center">在指定的集合范围之内，多选一</td></tr><tr><td align="center">NOT IN</td><td align="center">不在指定的集合范围之内</td></tr><tr><td align="center">ANY</td><td align="center">子查询返回列表中，有任意一个满足即可</td></tr><tr><td align="center">SOME</td><td align="center">与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td align="center">ALL</td><td align="center">子查询返回列表的所有值都必须满足</td></tr></tbody></table><h4 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h4><ul><li>查询 “销售部” 和 “市场部” 的所有员工信息<br>分解为以下两步:</li></ul><ol><li>查询 “销售部” 和 “市场部” 的部门ID<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li>根据部门ID, 查询员工信息<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;市场部&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ol><ul><li>查询比 财务部 所有人工资都高的员工信息<br>分解为以下两步:</li></ul><ol><li>查询所有 财务部 人员工资<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span>;<br><span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>比 财务部 所有人工资都高的员工信息<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span> ( <span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;财务部&#x27;</span>) );<br></code></pre></td></tr></table></figure></li></ol><ul><li>查询比研发部其中任意一人工资高的员工信息<br>分解为以下两步:</li></ul><ol><li>查询研发部所有人工资<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li>比研发部其中任意一人工资高的员工信息<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">any</span> ( <span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>) );<br></code></pre></td></tr></table></figure></li></ol><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。<br>常用的操作符：<code>=</code>、<code>&lt;&gt;</code> 、<code>IN</code> 、<code>NOT IN</code></p><h4 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h4><ul><li>查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;<br>这个需求同样可以拆解为两步进行:</li></ul><ol><li><p>查询 “张无忌” 的薪资及直属领导</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张无忌&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (salary,managerid) <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张无忌&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><p>子查询返回的结果是多行多列，这种子查询称为表子查询。<br>常用的操作符：<code>IN</code></p><h4 id="案例-8"><a href="#案例-8" class="headerlink" title="案例"></a>案例</h4><ul><li>查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息<br>分解为两步执行:</li></ul><ol><li><p>查询 “鹿杖客” , “宋远桥” 的职位和薪资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> job, salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;鹿杖客&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;宋远桥&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (job,salary) <span class="hljs-keyword">in</span> ( <span class="hljs-keyword">select</span> job, salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;鹿杖客&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;宋远桥&#x27;</span> );<br></code></pre></td></tr></table></figure></li></ol><ul><li>查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息<br>分解为两步执行:</li></ul><ol><li><p>入职日期是 “2006-01-01” 之后的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询这部分员工, 对应的部门信息;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id ;<br></code></pre></td></tr></table></figure></li></ol><h2 id="多表查询案例"><a href="#多表查询案例" class="headerlink" title="多表查询案例"></a>多表查询案例</h2><p>数据环境准备:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> salgrade(<br>    grade <span class="hljs-type">int</span>,<br>    losal <span class="hljs-type">int</span>,<br>    hisal <span class="hljs-type">int</span><br>) comment <span class="hljs-string">&#x27;薪资等级表&#x27;</span>;<br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3001</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">3</span>,<span class="hljs-number">5001</span>,<span class="hljs-number">8000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">4</span>,<span class="hljs-number">8001</span>,<span class="hljs-number">10000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">5</span>,<span class="hljs-number">10001</span>,<span class="hljs-number">15000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">6</span>,<span class="hljs-number">15001</span>,<span class="hljs-number">20000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">7</span>,<span class="hljs-number">20001</span>,<span class="hljs-number">25000</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> salgrade <span class="hljs-keyword">values</span> (<span class="hljs-number">8</span>,<span class="hljs-number">25001</span>,<span class="hljs-number">30000</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>). 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）<br>表: emp , dept<br>连接条件: emp.dept_id <span class="hljs-operator">=</span> dept.id<br><span class="hljs-keyword">select</span> e.name , e.age , e.job , d.name <span class="hljs-keyword">from</span> emp e , dept d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><br><br><span class="hljs-number">2</span>). 查询年龄小于<span class="hljs-number">30</span>岁的员工的姓名、年龄、职位、部门信息（显式内连接）<br>表: emp , dept<br>连接条件: emp.dept_id <span class="hljs-operator">=</span> dept.id<br><span class="hljs-keyword">select</span> e.name , e.age , e.job , d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">where</span> e.age <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>;<br><br><br><span class="hljs-number">3</span>). 查询拥有员工的部门ID、部门名称<br>表: emp , dept<br>连接条件: emp.dept_id <span class="hljs-operator">=</span> dept.id<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> d.id , d.name <span class="hljs-keyword">from</span> emp e , dept d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br><br><br><span class="hljs-number">4</span>). 查询所有年龄大于<span class="hljs-number">40</span>岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接)<br>表: emp , dept<br>连接条件: emp.dept_id <span class="hljs-operator">=</span> dept.id<br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">where</span> e.age <span class="hljs-operator">&gt;</span> <span class="hljs-number">40</span> ;<br><br><br><span class="hljs-number">5</span>). 查询所有员工的工资等级<br>表: emp , salgrade<br>连接条件 : emp.salary <span class="hljs-operator">&gt;=</span> salgrade.losal <span class="hljs-keyword">and</span> emp.salary <span class="hljs-operator">&lt;=</span> salgrade.hisal<br><span class="hljs-comment">-- 方式一</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span> , s.grade , s.losal, s.hisal <span class="hljs-keyword">from</span> emp e , salgrade s <span class="hljs-keyword">where</span> e.salary <span class="hljs-operator">&gt;=</span> s.losal <span class="hljs-keyword">and</span> e.salary <span class="hljs-operator">&lt;=</span> s.hisal;<br><span class="hljs-comment">-- 方式二</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span> , s.grade , s.losal, s.hisal <span class="hljs-keyword">from</span> emp e , salgrade s <span class="hljs-keyword">where</span> e.salary <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal;<br><br><br><span class="hljs-number">6</span>). 查询 &quot;研发部&quot; 所有员工的信息及 工资等级<br>表: emp , salgrade , dept<br>连接条件 : emp.salary <span class="hljs-keyword">between</span> salgrade.losal <span class="hljs-keyword">and</span> salgrade.hisal ,<br>emp.dept_id <span class="hljs-operator">=</span> dept.id<br>查询条件 : dept.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span> , s.grade <span class="hljs-keyword">from</span> emp e , dept d , salgrade s <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">and</span> (e.salary <span class="hljs-keyword">between</span> s.losal <span class="hljs-keyword">and</span> s.hisal ) <span class="hljs-keyword">and</span> d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br><br><br><span class="hljs-number">7</span>). 查询 &quot;研发部&quot; 员工的平均工资<br>表: emp , dept<br>连接条件 : emp.dept_id <span class="hljs-operator">=</span> dept.id<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e.salary) <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">and</span> d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br><br><br><span class="hljs-number">8</span>). 查询工资比 &quot;灭绝&quot; 高的员工信息。<br>①. 查询 &quot;灭绝&quot; 的薪资<br><span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;灭绝&#x27;</span>;<br>②. 查询比她工资高的员工数据<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> ( <span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;灭绝&#x27;</span> );<br><br><br><span class="hljs-number">9</span>). 查询比平均薪资高的员工信息<br>①. 查询员工的平均薪资<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary) <span class="hljs-keyword">from</span> emp;<br>②. 查询比平均薪资高的员工信息<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">&gt;</span> ( <span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary) <span class="hljs-keyword">from</span> emp );<br><br><br><span class="hljs-number">10</span>). 查询低于本部门平均工资的员工信息<br>①. 查询指定部门平均薪资<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e1.salary) <span class="hljs-keyword">from</span> emp e1 <span class="hljs-keyword">where</span> e1.dept_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e1.salary) <span class="hljs-keyword">from</span> emp e1 <span class="hljs-keyword">where</span> e1.dept_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>②. 查询低于本部门平均工资的员工信息<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e2 <span class="hljs-keyword">where</span> e2.salary <span class="hljs-operator">&lt;</span> ( <span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e1.salary) <span class="hljs-keyword">from</span> emp e1 <span class="hljs-keyword">where</span> e1.dept_id <span class="hljs-operator">=</span> e2.dept_id );<br><br><br><span class="hljs-number">11</span>). 查询所有的部门信息, 并统计部门的员工人数<br><span class="hljs-keyword">select</span> d.id, d.name , ( <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id ) <span class="hljs-string">&#x27;人数&#x27;</span> <span class="hljs-keyword">from</span> dept d;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tag文件与Tag标记</title>
    <link href="/2023/05/04/jsp-3/"/>
    <url>/2023/05/04/jsp-3/</url>
    
    <content type="html"><![CDATA[<p><font size=6><strong>目录</strong></font></p><ul><li><a href="#tag%E6%96%87%E4%BB%B6">tag文件</a><ul><li><a href="#tag%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84">tag文件的结构</a></li><li><a href="#tag%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E5%AD%98">tag文件的保存</a><ul><li><a href="#tag%E6%96%87%E4%BB%B6%E6%89%80%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%95">tag文件所在的目录</a></li><li><a href="#tag%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81">tag文件的编码</a></li></ul></li></ul></li><li><a href="#tag%E6%A0%87%E8%AE%B0">tag标记</a><ul><li><a href="#tag%E6%A0%87%E8%AE%B0%E4%B8%8Etag%E6%96%87%E4%BB%B6">tag标记与tag文件</a></li><li><a href="#tag%E6%A0%87%E8%AE%B0%E7%9A%84%E4%BD%BF%E7%94%A8">tag标记的使用</a></li><li><a href="#tag%E6%A0%87%E8%AE%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86">tag标记的运行原理</a></li></ul></li><li><a href="#tag%E6%96%87%E4%BB%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">tag文件的常用指令</a><ul><li><a href="#tag%E6%8C%87%E4%BB%A4">tag指令</a></li><li><a href="#include%E6%8C%87%E4%BB%A4">include指令</a></li><li><a href="#attribute%E6%8C%87%E4%BB%A4">attribute指令</a></li><li><a href="#variable%E6%8C%87%E4%BB%A4">variable指令</a></li><li><a href="#taglib%E6%8C%87%E4%BB%A4">taglib指令</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><h1 id="tag文件"><a href="#tag文件" class="headerlink" title="tag文件"></a>tag文件</h1><h2 id="tag文件的结构"><a href="#tag文件的结构" class="headerlink" title="tag文件的结构"></a>tag文件的结构</h2><p>Tag文件是扩展名为.tag的文本文件，其结构与jsp文件类似<br>可以被jsp页面动态加载调用,实现代码的复用(但用户不能直接通过该Tag文件所在的Web服务目录直接访问Tag文件)<br>包含:  </p><ul><li>HTML标记符</li><li>特殊的指令标记</li><li>成员变量和方法的定义</li><li>Java程序片和Java表达式</li></ul><h2 id="tag文件的保存"><a href="#tag文件的保存" class="headerlink" title="tag文件的保存"></a>tag文件的保存</h2><h3 id="tag文件所在的目录"><a href="#tag文件所在的目录" class="headerlink" title="tag文件所在的目录"></a>tag文件所在的目录</h3><p>建立目录结构</p><p><code>Web服务目录\WEB-INF\tags</code></p><ul><li>其中的WEB-INF（字母大写）和tags都是固定的目录名称，而tags下的子目录的名称可由用户给定。</li><li>一个Tag文件必须保存到tags目录或其下的子目录中。</li></ul><h3 id="tag文件的编码"><a href="#tag文件的编码" class="headerlink" title="tag文件的编码"></a>tag文件的编码</h3><p>保存Tag文件时按照Tag文件指定的编码保存<br>例如:<br><code>&lt;%@ tag pageEncoding=&quot;utf-8&quot;%&gt;</code>  </p><h1 id="tag标记"><a href="#tag标记" class="headerlink" title="tag标记"></a>tag标记</h1><h2 id="tag标记与tag文件"><a href="#tag标记与tag文件" class="headerlink" title="tag标记与tag文件"></a>tag标记与tag文件</h2><p>某个Web服务目录下的Tag文件只能由该Web服务目录中的JSP页面调用,JSP页面必须通过Tag标记来调用一个Tag文件<br>Tag标记的名字和Tag文件的名字一致，也就是说，当我们编写了一个Tag文件并保存到特定目录中后,也就给出了一个Tag标记，tag格式为:<br><code>&lt;Tag文件的名字/&gt;</code><br>或者<br><code>&lt;Tag文件的名字&gt;其他内容（称为标体内容）&lt;/Tag文件的名字&gt;</code></p><ul><li>一个Tag文件对应一个Tag标记，把全体Tag标记称为一个自定义标记库或简称为标记库</li></ul><h2 id="tag标记的使用"><a href="#tag标记的使用" class="headerlink" title="tag标记的使用"></a>tag标记的使用</h2><p>一个jsp页面通过使用tag标记来调用一个Tag文件。Web服务目录下的一个jsp页面使用tag标记调用文件之前，必须首先使用taglib指令标记引入该web服务目录下的标记库，只有这样jsp才能调用相应的tag文件</p><p>taglib指令的格式如下:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@taglib</span> tagdir=<span class="hljs-string">&#x27;标记库的位置&#x27;</span> prefix=<span class="hljs-string">&#x27;前缀&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@taglib</span> tagdir=<span class="hljs-string">&#x27;/WEB-INF/tags&#x27;</span> prefix=<span class="hljs-string">&#x27;computer&#x27;</span>%&gt;<br></code></pre></td></tr></table></figure><ul><li>引入标记库后，JSP页面就可以使用带前缀的Tag标记调用相应的Tag文件，其中的前缀由<code>&lt;taglib&gt;</code>指令中的<code>prefix</code>属性指定。</li><li>前缀就像一个目录的别名<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;前缀:Tag文件名&gt;<br></code></pre></td></tr></table></figure>例如:<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;computer:oddNumberSum&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="tag标记的运行原理"><a href="#tag标记的运行原理" class="headerlink" title="tag标记的运行原理"></a>tag标记的运行原理</h2><ol><li>如果该Tag标记对应的Tag文件是首次被JSP页面调用，那么Tomcat服务器会将Tag文件转译成一个java文件，并编译这个java文件生成字节码文件，然后执行这个字节码文件（这和执行JSP页面的原理类似）。</li><li>如果该Tag文件已经被转编译为字节码文件，Tomcat服务器将直接执行这个字节码文件。</li><li>如果对Tag文件进行了修改，那么Tomcat服务器会重新将Tag文件转译成一个java文件，并编译这个java文件生成字节码文件，然后执行这个字节码文件。</li></ol><h1 id="tag文件的常用指令"><a href="#tag文件的常用指令" class="headerlink" title="tag文件的常用指令"></a>tag文件的常用指令</h1><h2 id="tag指令"><a href="#tag指令" class="headerlink" title="tag指令"></a>tag指令</h2><p>类似于JSP文件中的page指令。Tag文件通过使用tag指令可以指定某些属性的值<br>Tag指令的语法如下:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ tag 属性<span class="hljs-number">1</span>=<span class="hljs-string">&#x27;属性值&#x27;</span> 属性<span class="hljs-number">2</span>=<span class="hljs-string">&#x27;属性值&#x27;</span>---属性n=<span class="hljs-string">&#x27;属性值&#x27;</span>% &gt;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ tag 属性<span class="hljs-number">1</span>=<span class="hljs-string">&#x27;属性值&#x27;</span> % &gt;<br>&lt;%@ tag 属性<span class="hljs-number">2</span>=<span class="hljs-string">&#x27;属性值&#x27;</span> % &gt;<br>&lt;%@ tag 属性<span class="hljs-number">3</span>=<span class="hljs-string">&#x27;属性值&#x27;</span> % &gt;<br>······<br>&lt;%@ tag 属性n=<span class="hljs-string">&#x27;属性值&#x27;</span> % &gt;<br></code></pre></td></tr></table></figure><ul><li><p>language属性<br>用于指定Tag文件使用的脚本语言<br>目前只能取值<code>java</code>，其默认值就是<code>java</code>，没有必要使用tag指令指定language属性的值。</p></li><li><p>import属性<br>import属性的作用是为Tag文件引入包中的类import属性默认已经有如下值：<code>java.lang.*</code>、 <code>javax.servlet.*</code>、<code>javax.servlet.jsp.*</code>、<code>javax.servlet.http.*</code>。</p></li></ul><p>c.pageEncording<br>该属性指定Tag文件的字符编码，其默认值是<code>ISO-8859-1</code>。目前，为了避免显示信息出现乱码现象，Tag文件需要将该属性值设置为<code>utf-8</code>。</p><h2 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h2><p>Tag文件中也有和JSP文件类似的include指令标记，其使用方法和作用与JSP文件中的include指令标记类似。</p><h2 id="attribute指令"><a href="#attribute指令" class="headerlink" title="attribute指令"></a>attribute指令</h2><ul><li><p>在tag文件中通过<code>attribute指令</code>让使用它的jsp页面向该页面tag文件传递需要的数据。<br>方式如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tag">&lt;%@ attribute name=&quot;对象名字&quot; required=&quot;ture&quot;|&quot;false&quot; type =&quot;对象的类型&quot;%&gt;<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tag">&lt;%@ attribute name=&quot;reuslt&quot; required=&quot;ture&quot; type=&quot;java.lang.Double&quot;%&gt;<br></code></pre></td></tr></table></figure><ul><li>相当于tag文件中有了一个名字是result的对象，但Tag文件不需要创建该对象result，而是等待JSP页面将一个Double型的对象的引用传递给result。</li><li><code>attribute指令</code>中的name属性时必需的,该属性的值时一个对象的名字.JSP页面在调用Tag文件时,可向name属性指定的对象传递一个引用</li><li>type在指定对象类型时,必须使用包名,比如,不可以将java.lang.Double简写为Double. 若没指定 默认为java.lang.String类型</li></ul></li><li><p>JSP页面使用Tag文件所调用的Tag文件中name指定的对象传递一个引用，方式如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;前缀:Tag文件名字 对象名字=<span class="hljs-string">&quot;对象的引用&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;computer:<span class="hljs-type">mayTag</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;new Double(3.1415926)&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>jsp页面使用Tag标记(假定标记的前缀为computer)调用myTag.tag ,向myTag.tag中attribute指令给出的对象result 传递了一个Double对象的引用</p></li><li><p>注: 在Tag文件中不可以再定义和attribute指令中的name属性给出的对象具有相同名字的遍历,否则将隐藏attribute指令中给出的对象,使其失效</p></li></ul><h2 id="variable指令"><a href="#variable指令" class="headerlink" title="variable指令"></a>variable指令</h2><p>Tag文件通过使用<code>variable指令</code>可以将Tag文件中的对象返回给调用该Tag文件的JSP页面，(即Tag文件返回数据给JSP页面)<br>格式如下：  </p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ variable name-given=<span class="hljs-string">&quot;对象名&quot;</span> variable-class=<span class="hljs-string">&quot;对象类型&quot;</span> scope=<span class="hljs-string">&quot;有效范围&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ul><li><p>name-givenTag<br>返回给jsp页面的对象，由字母，数字，下画线和美元符号组成</p></li><li><p>variable-class<br>返回的对象的类型，必须要完整包名，默认为java.lang.String类型</p></li><li><p>scope<br>  可以取：AT_BEGIN、NESTED和AT_END。</p><ul><li>AT_BEGIN：一开始使用Tag标记，就得到了返回的对象</li><li>NESTED：只可以在Tag标记的标记体中使用返回的对象</li><li>AT_END：在Tag标记结束后，才能返回对象</li></ul></li><li><p>对象的返回<br>Tag文件必须将要返回的对象的名字和引用存储到Tomcat服务器提供的<code>内置对象jspContext</code>中,JSP页面才能使用该对象<br>具体为<code>jspContext</code>调用<code>setAttribute(&quot;对象名&quot;,对象的引用)</code>;<br>之后jsp可以直接使用返回的对象.</p></li></ul><h2 id="taglib指令"><a href="#taglib指令" class="headerlink" title="taglib指令"></a>taglib指令</h2><p>引入标记库，格式如下</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ taglib tagdir=<span class="hljs-string">&quot;自定义标记库的位置&quot;</span> prefix=<span class="hljs-string">&quot;前缀&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>JSP页面或Tag文件都可以使用taglib指令使用标记库</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>先在jsp文件中 通过<code>taglib指令</code> 引入标记库(tag文件所在目录) <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ taglib tagdir=<span class="hljs-string">&quot;自定义标记库的位置&quot;</span> prefix=<span class="hljs-string">&quot;前缀&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li>再在引入的tag文件中通过<code>attribute指令</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tag">&lt;%@ attribute name=&quot;对象名字&quot; required=&quot;ture&quot;|&quot;false&quot; type =&quot;对象的类型&quot;%&gt;<br></code></pre></td></tr></table></figure>让使用它的jsp文件向该tag文件传递引用给<code>name</code><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;前缀:Tag文件名字 对象名字=<span class="hljs-string">&quot;对象的引用&quot;</span>/&gt;   <span class="hljs-comment">//前缀为taglib指令中指定的prefix</span><br></code></pre></td></tr></table></figure>之后tag文件中可自由使用已被传递引用的 <code>name</code></li><li>在 tag 文件中通过使用<code>variable指令</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tag">&lt;%@ variable name-given=&quot;对象名&quot; variable-class=&quot;对象类型&quot; scope=&quot;有效范围&quot;&gt;<br></code></pre></td></tr></table></figure>再通过<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tag">jspContext.setAttribute(&quot;对象名&quot;,对象的引用);<br></code></pre></td></tr></table></figure>“对象名”返回给使用该tag文件的jsp页面<br>使得jsp可以 自由使用返回的”对象名”</li></ol>]]></content>
    
    
    <categories>
      
      <category>JSP</category>
      
      <category>第三章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树与二叉树</title>
    <link href="/2023/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>三种方式都比较简单 原理相同</p><h4 id="递归先序"><a href="#递归先序" class="headerlink" title="递归先序"></a>递归先序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_front</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!T)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,T-&gt;data);<br>    DisplayTree_front(T-&gt;lchild);<br>    DisplayTree_front(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递归中序"><a href="#递归中序" class="headerlink" title="递归中序"></a>递归中序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_middle</span><span class="hljs-params">(Bitree T)</span>&#123;t<br>    <span class="hljs-title function_">if</span><span class="hljs-params">(!T)</span><br>        <span class="hljs-keyword">return</span>;<br>    DisplayTree_middle(T-&gt;lchild);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,T-&gt;data);<br>    DisplayTree_middle(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递归后续"><a href="#递归后续" class="headerlink" title="递归后续"></a>递归后续</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_back</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!T)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    DisplayTree_back(T-&gt;lchild);<br>    DisplayTree_back(T-&gt;rchild);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,T-&gt;data);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p>非递归先序遍历与非递归中序遍历原理相同 且比较简单</p><h4 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_front_unrec</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    LinkStack s;<br>    InitLStack(&amp;s);<br>    BitreeNode *p=T;<br>    <span class="hljs-keyword">while</span>(p|| EmptyStack(s))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            PushStack(&amp;s,p);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,p-&gt;data);<br>            p=p-&gt;lchild;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            p= PopStack(&amp;s);<br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_In_unrec</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    LinkStack s;<br>    InitLStack(&amp;s);<br>    BitreeNode *p=T;<br>    <span class="hljs-keyword">while</span>(p|| EmptyStack(s))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            PushStack(&amp;s,p);<br>            p=p-&gt;lchild;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            p= PopStack(&amp;s);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,p-&gt;data);<br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="非递归后续遍历"><a href="#非递归后续遍历" class="headerlink" title="非递归后续遍历"></a>非递归后续遍历</h4><p>与前两者不同，后续遍历中，要保证左孩子和右孩子都已被访问并且先访问左孩子后访问右孩子才能访问根节点。<br>算法思想：<br>    1. 从根节点开始，沿着左结点依次向下搜索，直到没有左结点的节点，全部按顺序依次入栈<br>    2. <strong>读取栈顶元素</strong>，判断其是否有右节点且是否被输出过，若有右结点且右结点没别访问过，则指针转向右结点，并执行 1 ；若没有右结点<strong>或者</strong>右节点已经被输出了，则出栈顶元素并输出该结点。<br>    3. 需要一个指针用于记录上一个输出的结点， 若一个结点的右孩子等于r，即该结点右节点已被输出，说明该结点所有子节点都被输出完了，该输出它自己了</p><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DispalyTree_back_unrec</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    LinkStack s;<br>    InitLStack(&amp;s);<br>    BitreeNode *p=T;<br>    BitreeNode *r=<span class="hljs-literal">NULL</span>;                 <span class="hljs-comment">//用于指向上一个输出的节点</span><br>    <span class="hljs-keyword">while</span>(p|| EmptyStack(s))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;                          <span class="hljs-comment">//沿着左节点依次向下，全部入栈，直到为空</span><br>            PushStack(&amp;s,p);<br>            p=p-&gt;lchild;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            p=GetTop(s);                        <span class="hljs-comment">//读取栈顶元素</span><br>            <span class="hljs-keyword">if</span>(p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)         <span class="hljs-comment">//若栈顶元素右结点存在，且未被输出</span><br>                p=p-&gt;rchild;                    <span class="hljs-comment">//转向结点</span><br>            <span class="hljs-keyword">else</span>&#123;                               <span class="hljs-comment">//否则,出栈并输出</span><br>                p=PopStack(&amp;s);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,p-&gt;data);<br>                r=p;                            <span class="hljs-comment">//用于记录最后一个被输出的结点</span><br>                p=<span class="hljs-literal">NULL</span>;                         <span class="hljs-comment">//p置空,进入下一次循环</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h2><h2 id="做题总结"><a href="#做题总结" class="headerlink" title="做题总结"></a>做题总结</h2><ul><li><p>在二叉树的前序序列、中序序列和后序序列中，所有<strong>叶子结点</strong>的前后顺序完全相同</p></li><li><p><strong>线索二叉树是一种物理结构</strong></p><ul><li>二叉树是一种逻辑结构，而线索二叉树明确指明了在存储过程中的数据存放方式，就是物理结构了。（物理结构&#x3D;存储结构）</li><li>若即指明了存储结构，又指明了逻辑结构的情况就是单独的“物理结构”，所以说线索二叉树是一种逻辑和存储结构是错误的，没有这种说法</li></ul></li><li><p>在中序线索树中，若某结点有左孩子，则其前驱结点是它左子树的最右下结点；若某结点有右孩子，则其后继结点时它右子树的最左下结点。</p></li><li><p>线索二叉树找前驱后继问题</p></li></ul><table><thead><tr><th></th><th align="center">先序线索二叉树</th><th align="center">中序线索二叉树</th><th align="center">后续线索二叉树</th></tr></thead><tbody><tr><td>找前驱</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td>找后继</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr></tbody></table><p>除非用三叉链表，或者用土方法从根开始遍历</p><ul><li>后序线索树的遍历仍需要</li></ul><p>二叉树线索化后，对于遍历我们仅需要关注非叶节点，在前序和中序的非叶节点中我们都能通过其孩子的指针找到其遍历后续，而后序的非叶节点不一定能确保能找到遍历后续</p><p><img src="/2023/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/2023-04-26-21-29-14.png"></p><ul><li><p>※前序遍历序列和后序遍历序列不能确定一棵树，但是能确定结点的父子关系<br>如：<br>  前序：根左右,相对顺序：根左，根右，左右<br>  后续：左右根,相对顺序：左根，右根，左右<br>可以得出：<br><font color="#0df2c9">两个结点，在前序和后续中的前后关系不同，证明二者是父子关系，如果相同，二者是兄弟关系</font></p><ul><li><strong>若遇到前中后序列相同相同问题，思路可以是分析其<code>相对顺序</code>来找出规律</strong></li></ul></li><li><p><strong>技巧</strong>：根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：  </p><ul><li><font color="#0df2c9">前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序</font></li><li><font color="#0df2c9">对于n个不同元素进栈，出栈序列的个数为 $\frac{1}{n+1} C_{2n}^{n} $</font></li></ul></li></ul><h2 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h2><h3 id="做题总结-1"><a href="#做题总结-1" class="headerlink" title="做题总结"></a>做题总结</h3><ul><li>树与森林的遍历和二叉树遍历的对应关系</li></ul><table><thead><tr><th align="center">树</th><th align="center">森林</th><th align="center">二叉树</th></tr></thead><tbody><tr><td align="center">先根遍历</td><td align="center">先序遍历</td><td align="center">先序遍历</td></tr><tr><td align="center">后根遍历</td><td align="center">中序遍历</td><td align="center">中序遍历</td></tr></tbody></table><p>举例判断即可</p><h2 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h2><h3 id="做题总结-2"><a href="#做题总结-2" class="headerlink" title="做题总结"></a>做题总结</h3><ul><li>定长编码集要保证所有的编码在同一层</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础-1-基础算法（二）</title>
    <link href="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><p><code>c++</code>才需要<br><code>Java</code>和<code>Python</code>是不需要高精度计算的，因为这两个语言直接支持高精度数据。</p><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p><a href="https://www.acwing.com/problem/content/793/">题目791.</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-22-13-03-04.png"><br>完整代码:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//C=A+B</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;      <span class="hljs-comment">//加引用是为了提高效率,不用copy一遍</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;      <span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>())  t+=A[i];<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())  t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t=t/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a,b;         <span class="hljs-comment">//用字符串读入</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;    <span class="hljs-comment">//存到vector里去</span><br>    cin &gt;&gt; a&gt;&gt; b;       <span class="hljs-comment">//正序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);  <span class="hljs-comment">//逆序//-&#x27;0&#x27;是因为a[i]中存的是字母 而我们需要存的是数字</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">add</span>(A,B);            <span class="hljs-comment">//auto就是编译器可以自己识别自己需要的类型并转变为它</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>大整数存储<ul><li>存入数组,低位在前,这样进位添加高位直接在数组后面插入即可</li></ul></li><li>模拟人工加法过程<ul><li>A<sub>i</sub>+B<sub>i</sub>+t(进位: 0 or 1)</li></ul></li></ul><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>函数使用引用或指针一般能使代码速度更快,占用空间更小</li><li>上面完整代码和代码模板思路是一样的 都可以写</li><li>auto就是编译器可以自己识别自己需要的类型并转变为它</li><li>用字符串读入数字后,要传入数组需要将其-‘0’</li></ul><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>题目:<a href="https://www.acwing.com/problem/content/794/">高进度减法</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-23-13-10-08.png"><br>完整代码:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//判断A&gt;=B</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>())   <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(A[i]!=B[i])  <span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//C=A-B</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t=A[i]-t;<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())  t-=B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);              <span class="hljs-comment">//t&gt;=0 t;t&lt;0 t+10</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t=<span class="hljs-number">1</span>;                         <span class="hljs-comment">//判断是否借位</span><br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)   C.<span class="hljs-built_in">pop_back</span>();   <span class="hljs-comment">//去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin &gt;&gt; a&gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))&#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(B,A);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>大致与加法相同</li><li>判断<code>A≥B</code> 若 <code>ture</code> 则 直接算<code>A-B</code>, 若<code>false</code> 则算<code>-(B-A)</code></li><li>判断<code>A[i]-B[i]-t</code> ,若<code>≥0</code>,则<code>A[i]-B[i]-t</code>;若<code>&lt;0</code>,则<code>A[i]-B[i]+10-t</code></li><li>去掉前导<code>0</code></li></ol><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;                                <span class="hljs-comment">//判断是否借位</span><br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-comment">//去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>不要忘记去掉前导零<ul><li>注意一位的时候无需去除 结果就是0</li></ul></li><li><code>(t+10)%10</code><ul><li><code>t&gt;=0</code> 结果为<code>t</code></li><li><code>t&lt;0</code>  结果为<code>t+10</code></li></ul></li><li>完整代码中的cmp函数写的很精简优美.</li></ul><h2 id="高精度乘以低精度"><a href="#高精度乘以低精度" class="headerlink" title="高精度乘以低精度"></a>高精度乘以低精度</h2><p>题目:<a href="https://www.acwing.com/problem/content/795/">高精度乘法</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-23-19-00-53.png"><br>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mult</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i]*b;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t=t/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>&amp;&amp;C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)    C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">mult</span>(A,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><ol><li>用大数的每一位 分别乘以小数 再加上进位即可</li><li>去先导0</li></ol><h3 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h2><p><a href="https://www.acwing.com/problem/content/796/">高精度除法</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-23-21-47-56.png"><br>完整代码  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//A/B 商是C，余数是r</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> &amp;b,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;         <span class="hljs-comment">//是逆着存 A[0]存的低位</span><br>        r=A[i]+r*<span class="hljs-number">10</span>;<br>        C.<span class="hljs-built_in">push_back</span>(r/b);                   <span class="hljs-comment">//C顺着存  C[0]存的高位</span><br>        r=r%b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">//反转，使C逆着存 C[0]是低位</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>&amp;&amp;C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)    C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">div</span>(A,b,r);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----%d------&quot;</span>,A.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><h3 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>除法不同于加减乘，是由高位开始运算的，得出的结果也是高位在前,一般来说正着运算会好一点，但题目一般加减乘除一起出现，所以统一倒着来存</li><li>需要颠倒使得高位在后 可以比较方便的去先导零</li></ul><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="前缀和-1"><a href="#前缀和-1" class="headerlink" title="前缀和"></a>前缀和</h2><p><a href="https://www.acwing.com/problem/content/797/">题目</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-24-17-30-14.png"><br>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-comment">//前缀和的初始化</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="hljs-number">-1</span>]+a[i];    <span class="hljs-comment">//可与上一条循环语句一起写</span><br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);             <span class="hljs-comment">//区间和的计算</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]                <span class="hljs-comment">//初始化,即预处理</span><br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]          <span class="hljs-comment">//计算,即询问</span><br></code></pre></td></tr></table></figure><p>作用:   求某段区间的和</p><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意:"></a>注意:</h3><ul><li>预处理  O(n)</li><li>询问    O(1)</li><li>下标从1开始 避免了边界问题</li></ul><h2 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h2><p><a href="https://www.acwing.com/problem/content/798/">题目</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-24-18-09-57.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,m,q,a[N][N],s[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]),s[i][j]=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j];<span class="hljs-comment">//初始化，并求前缀和</span><br>    <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="hljs-number">-1</span>]-s[x1<span class="hljs-number">-1</span>][y2]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<span class="hljs-comment">//算子矩阵部分和</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码模板-5"><a href="#代码模板-5" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i, j] = 第i行j列格子左上部分所有元素的和 <br>    即s[i][j]=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j]<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br>    即s[x2][y2]-s[x2][y1<span class="hljs-number">-1</span>]-s[x1<span class="hljs-number">-1</span>][y2]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><h3 id="注意-4"><a href="#注意-4" class="headerlink" title="注意:"></a>注意:</h3><ul><li>下标从1开始</li></ul><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>本质是前缀和的逆运算</p><h2 id="差分-1"><a href="#差分-1" class="headerlink" title="差分"></a>差分</h2><p><a href="https://www.acwing.com/problem/content/799/">题目</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-24-20-53-34.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123; <span class="hljs-comment">//使得数组a在[l,r]区间上每个元素加上c</span><br>    b[l]+=c;<br>    b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]),<span class="hljs-built_in">insert</span>(i,i,a[i]); <span class="hljs-comment">//在构建数组a的同时 利用差分性质构建a的差分数组b</span><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   b[i]+=b[i<span class="hljs-number">-1</span>],<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i]);    <span class="hljs-comment">//数组b变成自己的前缀和,并输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>数组<code>a[1],a[2],a[3]...a[n]</code> ,构造<code>b[1],b[2],b[3]...b[n]</code> ,使得 <code>a[i]=b[1]+b[2]+...+b[i]</code>.此时<code>数组a</code>是<code>数组b</code>的<code>前缀和</code>  <code>数组b</code>是<code>数组a</code>的<code>差分</code></li><li>若<code>b[i]+c</code> 那么<code>a[i],a[i+1]....a[n]</code>都会加上<code>c</code>,若<code>b[i]-c</code> 那么<code>a[i],a[i+1]....a[n]</code>都会减上<code>c</code></li><li>由2可得 要使<code>数组a</code>的<code>[l,r]</code>区间内每个元素都加上<code>c</code>,可使<code>b[l]</code>加上<code>c</code>,<code>b[r+1]</code>减上<code>c</code></li><li>利用4 在构建<code>数组a</code> 的同时 构建<code>数组b</code></li></ol><h3 id="代码模板-6"><a href="#代码模板-6" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">给数组a区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><strong>※如何构造差分:利用 <code>数组a区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c</code> 的性质 可以在构建a数组的同时构建b数组 <em>设a b数组元素初始全为0</em>  若构建a数组时由0变为a[i]  根据特性此时b[i]+&#x3D;a[i] ,b[i+1]-&#x3D;c  ,数组a构建完成时,数组b也构建完成</strong></li><li>由数组b到数组a 时间复杂度需要O(n)</li><li>数组a [l,r] 中得每个数加上c 时间复杂度O(1)</li></ul><h2 id="差分矩阵"><a href="#差分矩阵" class="headerlink" title="差分矩阵"></a>差分矩阵</h2><p><a href="https://www.acwing.com/problem/content/800/">题目</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-24-21-12-17.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N][N],b[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[x1][y1]+=c;<br>    b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>    b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>    b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)   <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]),<span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);   <span class="hljs-comment">//构建矩阵a的同时，构建矩阵b</span><br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d %d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);                      <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)  <br>            b[i][j]+=b[i<span class="hljs-number">-1</span>][j]+b[i][j<span class="hljs-number">-1</span>]-b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i][j]);<span class="hljs-comment">//将矩阵b变成自己的前缀和并输出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码模板-7"><a href="#代码模板-7" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br>即:使得矩阵a的以[x1,y1]为左上角,[x2,y2]为右下角的子矩阵中的所有元素加上c<br>    b[x1][y1]+=c;<br>    b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>    b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>    b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSP语法</title>
    <link href="/2023/04/19/jsp-2/"/>
    <url>/2023/04/19/jsp-2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-JSP页面的基本结构"><a href="#1-JSP页面的基本结构" class="headerlink" title="1 JSP页面的基本结构"></a>1 JSP页面的基本结构</h1><ul><li>普通的HTML标记和jsp标记</li><li>JSP标记，如指令标记、动作标记</li><li>变量和方法的声明</li><li>Java 程序片</li><li>Java 表达式</li></ul><h1 id="2-声明变量和定义方法"><a href="#2-声明变量和定义方法" class="headerlink" title="2 声明变量和定义方法"></a>2 声明变量和定义方法</h1><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>格式:<code>&lt;%!变量%&gt;</code>  </p><ul><li>声明的变量在整个JSP页面内都有效</li></ul><h2 id="定于方法"><a href="#定于方法" class="headerlink" title="定于方法"></a>定于方法</h2><p>格式:<code>&lt;%!方法or类%&gt;</code>  </p><ul><li>可以在Java程序片中调用该方法或使用该类创造对象</li></ul><h1 id="3-Java程序片"><a href="#3-Java程序片" class="headerlink" title="3 Java程序片"></a>3 Java程序片</h1><p>格式:<code>&lt;%所插入的java程序片%&gt;</code></p><ul><li>在程序片中声明的变量称作JSP页面的局部变量。局部变量的有效范围与其声明的位置有关，即局部变量在JSP页面后继的所有程序片以及表达式部分内都有效。</li></ul><h1 id="4-Java表达式"><a href="#4-Java表达式" class="headerlink" title="4 Java表达式"></a>4 Java表达式</h1><p>格式:<code>&lt;%=可求值得表达式%&gt;</code></p><ul><li>注意:<code>&lt;%</code>和<code>=</code>之间不能有空格</li></ul><h1 id="5-JSP中的注释"><a href="#5-JSP中的注释" class="headerlink" title="5 JSP中的注释"></a>5 JSP中的注释</h1><h2 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h2><p>格式:<code>&lt;!--注释内容--&gt;</code></p><ul><li>JSP会把HTML注释交给用户,因此用户可在查看页面源码时看到HTML注释</li></ul><h2 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h2><p>格式:<code>&lt;% --注释内容--%&gt;</code></p><ul><li>在编译JSP页面时会忽略JSP注释</li></ul><h1 id="6-JSP指令标记"><a href="#6-JSP指令标记" class="headerlink" title="6 JSP指令标记"></a>6 JSP指令标记</h1><h2 id="page指令标记"><a href="#page指令标记" class="headerlink" title="page指令标记"></a>page指令标记</h2><p>page 指令用来定义整个JSP页面的一些属性和这些属性的值。<br>可以使用多个page指令分别为每个属性指定值:  </p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page   属性<span class="hljs-number">1</span>=<span class="hljs-string">&quot;属性1的值&quot;</span>  %&gt;<br>&lt;%@ page   属性<span class="hljs-number">2</span>=<span class="hljs-string">&quot;属性2的值&quot;</span>  %&gt;<br>… …<br>&lt;%@ page   属性n=<span class="hljs-string">&quot;属性n的值&quot;</span>  %&gt;<br></code></pre></td></tr></table></figure><p>也可以用一个page指令指定多个属性的值:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page 属性<span class="hljs-number">1</span>=<span class="hljs-string">&quot;属性1的值&quot;</span> 属性<span class="hljs-number">2</span>=<span class="hljs-string">&quot;属性2的值&quot;</span> ...%&gt;<br></code></pre></td></tr></table></figure><h3 id="page指令标记可以指定的属性"><a href="#page指令标记可以指定的属性" class="headerlink" title="page指令标记可以指定的属性"></a>page指令标记可以指定的属性</h3><h4 id="contentType属性"><a href="#contentType属性" class="headerlink" title="contentType属性"></a>contentType属性</h4><p>contentType属性值确定JSP页面响应的MIME类型。属性值的一般形式是： “MIME类型”<br>例如:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html &quot;</span> %&gt;<br></code></pre></td></tr></table></figure><ul><li>page指令只能为contentType指定一个值，不允许两次使用page指令给contentType属性指定不同的属性值。</li></ul><h4 id="pageEncoding-属性"><a href="#pageEncoding-属性" class="headerlink" title="pageEncoding 属性"></a>pageEncoding 属性</h4><p>用于保存JSP页面编码<br>例如:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ <span class="hljs-type">page</span> <span class="hljs-variable">pageEncoding</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;utf-8&quot;</span> %&gt;    <br></code></pre></td></tr></table></figure><ul><li>只能为pageEncoding指定一个值，不允许两次使用page指令给pageEncoding属性指定不同的或相同的属性值。</li></ul><h4 id="language属性"><a href="#language属性" class="headerlink" title="language属性"></a>language属性</h4><p>language属性定义JSP页面使用的脚本语言，该属性的值目前只能取”java”</p><ul><li>未指定,默认java</li></ul><h4 id="import-属性"><a href="#import-属性" class="headerlink" title="import 属性"></a>import 属性</h4><p>该属性的作用是为JSP页面引入Java运行环境提供的包中的类。<br>例如:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page  <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.*&quot;</span>, <span class="hljs-string">&quot;java.time.LocalDate&quot;</span> %&gt;<br></code></pre></td></tr></table></figure><h4 id="session属性"><a href="#session属性" class="headerlink" title="session属性"></a>session属性</h4><p>session 属性用于设置是否需要使用内置的session对象。session的属性值可以是true或false。session属性默认的属性值是true</p><h4 id="buffer属性"><a href="#buffer属性" class="headerlink" title="buffer属性"></a>buffer属性</h4><p>内置输出流对象out负责将服务器的某些信息或运行结果发送到用户端显示。buffer属性用来指定out设置的缓冲区的大小或不使用缓冲区 </p><ul><li>默认时8kb<br>例如:<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page buffer= <span class="hljs-string">&quot;24kb&quot;</span> %&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="autoFlush属性"><a href="#autoFlush属性" class="headerlink" title="autoFlush属性"></a>autoFlush属性</h4><p>autoFlush属性指定out的缓冲区被填满时，缓冲区是否会自动刷新。</p><ul><li>默认是true</li></ul><h4 id="isThreadSafe属性"><a href="#isThreadSafe属性" class="headerlink" title="isThreadSafe属性"></a>isThreadSafe属性</h4><p>isThreadSafe属性用来设置访问JSP页面是否是线程安全的</p><ul><li>默认是true 指CPU的使用权在各个线程间快速切换</li><li>可设置为false 指该JSP页面同一时刻只能响应一个用户的请求，其他用户须排队等待</li></ul><h4 id="info-属性"><a href="#info-属性" class="headerlink" title="info 属性"></a>info 属性</h4><p>info属性的属性值是一个字符串，其目的时为JSP页面准备一个常用但可能要经常修改的字符串。<br>例如： </p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ <span class="hljs-type">page</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;we are students&quot;</span>%&gt;<br></code></pre></td></tr></table></figure><p>可以在jsp页面中使用方法：<code>getServletInfo();</code>来获取info属性的属性值  </p><h2 id="include指令标记"><a href="#include指令标记" class="headerlink" title="include指令标记"></a>include指令标记</h2><p>include可以在JSP页面内某处静态整体嵌入一个文件,该文件的编码必须和当前JSP页面一致</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;% @ <span class="hljs-type">include</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;文件的URL&quot;</span>%&gt;<br></code></pre></td></tr></table></figure><h1 id="7-JSP动作标记"><a href="#7-JSP动作标记" class="headerlink" title="7 JSP动作标记"></a>7 JSP动作标记</h1><p>动作标记时一种特殊的标记，它影响JSP运行时的功能。</p><h2 id="include动作标记"><a href="#include动作标记" class="headerlink" title="include动作标记"></a>include动作标记</h2><p>格式:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:include page= <span class="hljs-string">&quot;文件的URL&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:include page= <span class="hljs-string">&quot;文件的URL&quot;</span> &gt;<br>   param子标记<br>&lt;/jsp:include&gt;<br></code></pre></td></tr></table></figure><p>这个文件在JSP运行（Java文件的字节码文件被加载执行）时才包含进来</p><h2 id="param动作标记"><a href="#param动作标记" class="headerlink" title="param动作标记"></a>param动作标记</h2><p>param标记以<code>名字—值</code>对的形式为其他标记提供附加信息。<br>格式:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:param  name= <span class="hljs-string">&quot;参数&quot;</span>  value= <span class="hljs-string">&quot; 参数的值&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>该标记与<code>jsp:include</code>动作标记一起使用时,可以将<code>param标记</code>中参数的值传递到<code>include动作标记</code>要加载的文件中去,被加载的JSP文件可以通过使用Tomcat服务器提供的<code>request内置对象</code>获取<code>include动作标记</code>的<code>param子标记</code>中<code>name</code>给出的参数的值</p><h2 id="forward-动作标记"><a href="#forward-动作标记" class="headerlink" title="forward 动作标记"></a>forward 动作标记</h2><p>作用是从该指令处停止当前页面的执行，而转向执行page属性指定的JSP页面。<br>格式:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:forward page=<span class="hljs-string">&quot;要转向的页面&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:forward page=<span class="hljs-string">&quot;要转向的页面&quot;</span> &gt;<br>   param子标记<br>&lt;/jsp:forward&gt;<br></code></pre></td></tr></table></figure><ul><li>浏览器地址栏中显示的仍然是转向前的JSP页面的URL地址</li></ul><h2 id="useBean动作标记"><a href="#useBean动作标记" class="headerlink" title="useBean动作标记"></a>useBean动作标记</h2><p>useBean标记时用来创建并使用一个JavaBean，见后续章节</p>]]></content>
    
    
    <categories>
      
      <category>JSP</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础-1-基础算法（一）</title>
    <link href="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p> 可借助<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Comparison Sorting Algorithms</a>来理解</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>题目:<br><a href="https://www.acwing.com/problem/content/787/">快速排序</a><br><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-04-23-13-08-12.png"><br>完整代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//加10防止越界</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j),<span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>分治</strong></p><ol><li>确定分界点：头 、尾 、（头＋尾）&#x2F;2、 随机</li><li>调整区间，使得小于分界点的数全在其左边，大于分界点的数全在右边<ul><li>利用两个指针在数列两头向中间移动，左边的指针在碰到大于等于分界点时停下，右边的指针反之，都停下时交换两数，循环上述过程，直到两指针相交</li></ul></li><li>递归排序左右两端</li></ol><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a><strong>代码模板</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">//区间元素一个或者没有</span><br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>时间复杂度 nlogn</p></li><li><p><strong>若x取q[l]或者q[r]要考虑边界问题</strong><br>若 递归处用 i-1 和 i ,则x<strong>不可以</strong>取q[l] ,<strong>可以</strong>取q[r]或者q[(l+r+1)&#x2F;2]或者q[l+r+1&gt;&gt;1]等<br>若 递归处用 j 和 j+1 ,则x<strong>不可以</strong>取q[r] ,<strong>可以</strong>取q[l]或者q[(l+r)&#x2F;2]或者q[l+r&gt;&gt;1]等<br>否则可能会出现死循环<br>例如:x取q[l],递归处用i-1和i,排序12,会无限调用递归quick_sort(q,0,1),即无限划分<br>具体见<code>分析</code></p></li><li><p><strong>快排是不稳定的</strong><br>在排序前，关键字值相等的不同记录，排序后相对位置保持不变的排序方法，称为稳定排序方法（但其实没软用）<br>如何把快排变成稳定的呢—————把快排每个数变成不同的，可把每个数据弄成二元组，双关键字排序</p></li><li><p>c++的sort是快排和插入的组合,小范围用插入,大范围用快排</p></li><li><p>scanf比cin快<br><code>ios::sync_with_stdio(false); </code>可以让cin变快，但是副作用是不能用scanf了</p></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h3><ul><li><strong>边界问题分析</strong><br>分治算法最怕<code>n分成0和n,或n分成n和0</code>,这会造成<em>无限划分</em><br>若<code>x=q[l]</code>时 最极端情况是<code>i=l,j=l</code> 此时若划分为<code>(l,i-1)</code>和<code>(i,r)</code> 其中<code>(i,r)</code>划分的就是<code>n</code> 这就出现了<em>无限划分</em><br>若<code>x=q[r]</code>时 最极端情况时<code>i=r,j=r</code> 此时若划分为<code>(l,j)</code>和<code>(j+1,r)</code> 其中<code>(l,j)</code>划分的就是<code>n</code> 这就出现了<em>无限划分</em></li><li>关于<code>q[l+r&gt;&gt;1]</code>和<code>q[l+r+1&gt;&gt;1]</code> 的问题,<br><code>q[l+r+1&gt;&gt;1]</code>是向上取整,因为向上取整时有可能取到q[r],为了避免<em>无限划分</em>,所以递归处划分应该是i-1和i<br><code>q[l+r&gt;&gt;1]</code>是向下取整,因为向下取整时有可能取到q[l],为了避免<em>无限划分</em>,所以递归处划分应该时j和j+1<br><a href="https://www.acwing.com/solution/content/16777/"></a></li></ul><p>最后<br>为什么y总要<code>const int N = 1e6+10;</code> 要加10呢 我也没懂 但参考:<a href="https://www.zhihu.com/question/35047872">知乎</a></p><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p><code>快排</code>的拓展</p><p><a href="https://www.acwing.com/problem/content/788/">第k个数</a></p><p><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-05-07-12-02-54.png"></p><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>在<code>快排</code>的基础上 每次只需要判断k在左区间还是右区间，一直递归排序k所在区间即可</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,k,q[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>,x=q[l+r&gt;&gt;<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(q[i]&lt;x);<br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(q[j]&gt;x);<br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(q[i],q[j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k&lt;=j) <span class="hljs-built_in">sort</span>(q,l,j,k);<br>    <span class="hljs-keyword">else</span>    <span class="hljs-built_in">sort</span>(q,j+<span class="hljs-number">1</span>,r,k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,k<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,q[k<span class="hljs-number">-1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li>快排时间复杂度O(nlogn) 快选时间复杂度O(n) <ul><li>n+n&#x2F;2+n&#x2F;4+…</li></ul></li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>题目：<br><a href="https://www.acwing.com/problem/content/789/">归并排序</a><br><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-04-23-13-08-41.png"><br>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],temp[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;            <br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">MergeSort</span>(q,l,mid),<span class="hljs-built_in">MergeSort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)<br>        <span class="hljs-keyword">if</span>(q[i]&lt;=q[j]) temp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> temp[k++]=q[j++];<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)   temp[k++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) temp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(i =l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)  q[i]=temp[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">MergeSort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>分治</p><ol><li>确定分界点：mid&#x3D;l+r&gt;&gt;1</li><li>递归排序left，right<ul><li>确保每个区间都已排好顺序</li></ul></li><li>归并————合二为一 （时间复杂度O(n)）<ul><li>归并的两个区间已通过递归排好顺序,后面只需逐一比较,放入小的数即可</li></ul></li></ol><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;                                <span class="hljs-comment">//区间内元素一个或者没有</span><br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        <span class="hljs-comment">//q[i]=q[j]先存入q[i] 使之稳定</span><br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];       <span class="hljs-comment">//注意此处i从l开始到r j也可以用k 但要记得++</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>时间复杂度 nlogn</li><li>归并时是带回的是原数组的l到r，临时数组从0开始</li><li>与快排对比来看，快排是双指针先排再分，归并是先分再排</li></ul><h3 id="逆序对的数量"><a href="#逆序对的数量" class="headerlink" title="逆序对的数量"></a>逆序对的数量</h3><p><code>归并</code>的拓展<br><a href="https://www.acwing.com/problem/content/790/">逆序对的数量</a></p><p><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-05-07-13-05-07.png"></p><h4 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h4><p><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-05-07-13-47-57.png"></p><h4 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],temp[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function">LL <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    LL res = <span class="hljs-built_in">MergeSort</span>(q,l,mid)+<span class="hljs-built_in">MergeSort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)<br>        <span class="hljs-keyword">if</span>(q[i]&lt;=q[j]) temp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> temp[k++]=q[j++],res += mid - i +<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)   temp[k++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r)     temp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(i =l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)  q[i]=temp[j];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,<span class="hljs-built_in">MergeSort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>));<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h4><ul><li>逆序对数量的最大值<ul><li>如果数组是倒序,逆序对数量能取得最大值  $\frac{n(n-1)}{2} $ &gt; int</li></ul></li></ul><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>题目:<br><a href="https://www.acwing.com/problem/content/791/">数的范围</a><br><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-04-23-13-09-07.png"><br>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <span class="hljs-comment">//确定左边界</span><br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;                     <span class="hljs-comment">//结束是l=r</span><br>            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;             <span class="hljs-comment">//mid是需要不断更新的值 放在循环内 </span><br>            <span class="hljs-keyword">if</span>(q[mid]&gt;=x)r=mid;         <span class="hljs-comment">//因为左边界右侧的数字都&gt;=x</span><br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(q[l]!=x)cout&lt;&lt;<span class="hljs-string">&quot;-1 -1&quot;</span>&lt;&lt;endl; <span class="hljs-comment">//无解</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;l&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;               <span class="hljs-comment">//输出左边界 l=r 所以输出r也可以</span><br>            <span class="hljs-comment">//确定右边界</span><br>            <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid]&lt;=x) l=mid;    <span class="hljs-comment">//右边界左边的数都&lt;=x</span><br>                <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            cout &lt;&lt; l &lt;&lt;endl;           <span class="hljs-comment">//输出右边界</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><p>二分的本质并不是单调性 有单调性一定可以二分 用二分的不一定有单调性<br>二分的本质是找<code>边界点</code> 每次二分时选择<strong>答案所在区间</strong> 当区间长度为1时 得出答案<br>若有某种性质使得一部分满足 另一部分不满足,二分可以用来寻找这个性质边界(两个边界对应两个模板)</p><h3 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><span class="hljs-comment">//右边成立 二分右边的分界点</span><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">//左边成立 二分左边的分界点</span><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;       <span class="hljs-comment">//向上取整</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>写法</strong></p><ol><li>先写一个mid(不确定向上or向下取整)</li><li>想一个check函数</li><li>根据check函数想如何划分再确定mid向上取整还是向下取整</li></ol><h3 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h3><ul><li>若模板二不能使用mid&#x3D;l+r&gt;&gt;1 即向下取整 此时如若l&#x3D;r-1 mid&#x3D;l 若check(mid)为true l&#x3D;mid&#x3D;l 进入死循环</li><li>二分是一定有解的(定义的性质一定有<code>边界</code>) 题目可能无解(根据二分出来的<code>边界</code>来判断有无解)</li><li>mid是需要不断更新的值 放在循环内</li></ul><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li><p><strong>边界问题</strong>:<br>关键在于缩小边界时l和r的取值是否会造成无限循环<br>如当<code>mid=l+r&gt;&gt;1</code>时 <code>mid</code>为向下取整 这时就有可能使得<code>mid=l</code> 而在缩小边界时,若使得<code>l=mid</code>,这无疑会产生无限循环,为此我们应该使得<code>mid</code>向上取整,即<code>mid=l+r+1&gt;&gt;1</code><br>同理有缩小边界使得<code>r=mid</code>,为了不让<code>mid</code>有可能取到<code>r</code>产生无限循环问题,应该使得<code>mid</code>向下取整,即<code>mid=l+r&gt;&gt;1</code><br>总结为:先不要确定mid向上取整还是向下取整,而是根据check函数来考虑缩小边界时是会使得<code>l</code>or<code>r</code>&#x3D;<code>mid</code><br>若<code>l=mid</code>,为了<strong>避免</strong><code>mid=l</code>的可能,我们使得<code>mid</code>向上取整,即<code>mid=l+r+1&gt;&gt;1</code><br>若<code>r=mid</code>,为了<strong>避免</strong><code>mid=r</code>的可能,我们使得<code>mid</code>向下取整,即<code>mid=l+r&gt;&gt;1</code><br><a href="https://www.acwing.com/solution/content/16798/"></a></p></li><li><p>if(check)中直接等于mid而else中+1-1问题<br>其实这要取决于我们所设置的check如例题中我们设置的是<code>q[mid]&gt;=x</code>条件,<br>若为<code>true</code>,那自然<code>mid</code>是满足条件的,所以边界<code>r</code>可以等于<code>mid</code><br>若为<code>false</code>,那自然<code>mid</code>是不满足条件的,所以边界<code>l</code>无疑不需要包含<code>mid</code><br><code>q[mid]&lt;=x</code>同理.</p></li></ul><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>浮点数二分因为没有<code>整除</code> 所以每次二分都能严格取一半 所以没有<code>边界问题</code> 所以很简单<br><a href="https://www.acwing.com/problem/content/792/">数的三次方根</a><br><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-04-23-13-09-33.png"><br>题目有坑(2个)<br>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> esp = <span class="hljs-number">1e-8</span>;<br><span class="hljs-type">double</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;n);<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">0</span>,r=n;<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">1</span>&amp;&amp;n&gt;<span class="hljs-number">-1</span>)&#123;                         <span class="hljs-comment">//考虑特殊考虑-1&lt;n&lt;1的情况 因为绝对值小于1时,区间[l,r]根本不包含答案</span><br>        l=<span class="hljs-number">-1</span>;<br>        r=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>   <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(l,r);             <span class="hljs-comment">//要考虑数为负数的情况 答案在[n,0]之间</span><br>    <span class="hljs-keyword">while</span>(r-l&gt;esp)&#123;<br>        <span class="hljs-type">double</span> mid = (l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid*mid&gt;=n)  r=mid;<br>        <span class="hljs-keyword">else</span>                l=mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,r);                        <span class="hljs-comment">//l or r 都可</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><p>每次二分答案都在区间内部 当区间很小时 就得出答案</p><h3 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;           <br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意-5"><a href="#注意-5" class="headerlink" title="注意"></a>注意</h3><ul><li>经验: 若题目要求保留n位小数 精度写1e-(n+2)</li><li>还有第二种写法 <ul><li>不用精度取迭代 而是直接循环100次 将<code>while (r - l &gt; eps)</code> 换成<code>for(int i=0;i&lt;100;i++)</code></li></ul></li><li>注意例题求数三次方根的两个坑<ul><li>考虑负数————交换l和r即可</li><li>考虑<code>-1&lt;n&lt;1</code>的情况,区间不包含答案————将区间设为[-1,1]即可</li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OS-5-1-I/O管理概述</title>
    <link href="/2023/04/16/OS-5-1-I-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/04/16/OS-5-1-I-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="94060cc29a25a6ae2d60cb0f113d7e64af161d3ac566f92ce1303476b7bab2f5">01d7cac278ef89b863b3c951eb8364ec4b25d326537b8cfd6c2b318ff2e7cfa758872eb047d069c0cf34aa459c9db87c6c72f86f81990875b47621bfd65b0d5d77689312dbb393e7163366c91bb7f08d114855cc10b619cb9136db1257c70a0c99ca2374520f5e22e8e7143a7f1c69e9a30286b42e38723dc30dc3587df00a67123c9df8c9baae833a27b753ddc4b21d52b3f69fd7c7559a4d06b6174a4cc0700cce844da0b046c0b79862ffad9e8bdbfabe584a006bdc828613970c05d74c6d9cbb33216423a30b380fe9fd0afe92c77470f723bea25f929ece3efe459727acd706f99b3d91449e96097fa59b78b2b143fbb64ff1d53e016dfb54d9df632947eddecf26d19e84d33b1b25c308fe9cdff172da9793c953440c779ecaab1818117de77533ebed35a5507aabd2b2681ef7d17ac183aa03b2945df01965af45df05</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里需要密码才能访问。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>第五章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pictest</title>
    <link href="/2023/04/15/pictest/"/>
    <url>/2023/04/15/pictest/</url>
    
    <content type="html"><![CDATA[<p>hexo如何更好的插入本地图片</p><hr><h1 id="全局资源文件夹"><a href="#全局资源文件夹" class="headerlink" title="全局资源文件夹"></a>全局资源文件夹</h1><p>hexo 全局资源文件夹<code>source/images</code>的图片可以直接用 markdown 语法 <code>![](image/someimage.jpg)</code>来引用,但图片放多了难以整理</p><h1 id="文章资源文件夹"><a href="#文章资源文件夹" class="headerlink" title="文章资源文件夹"></a>文章资源文件夹</h1><p>为了更有效的管理图片等资源可开启Hexo文章资源文件夹,可在<code>_config.yml</code>站点配置文件(注意是Hexo博客目录下,并非<code>theme/sometheme/_config.ml</code>)中进行修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>开启之后 每次 <code>hexo new [layout] &lt;title&gt;</code> 创建新文章时自动创建一个新同名文件夹 文件夹中的文件可直接用相对路径引用它们</p><h1 id="使用markdown嵌入图片"><a href="#使用markdown嵌入图片" class="headerlink" title="使用markdown嵌入图片"></a>使用markdown嵌入图片</h1><p>hexo-renderer-marked 3.1.0 引入了一个新的选项，其允许你无需使用 asset_img 标签插件就可以在 markdown 中嵌入图片</p><p>如需启用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">_config.yml</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>启用后，资源图片将会被自动解析为其对应文章的路径。<br>例如： <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code> ，这表示它是 <code>/2020/01/02/foo/</code> 文章的一张资源图片， <code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code> 。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>但是我们每次插入图片要放入相应文件夹很麻烦,为此我们在vscode 安装 Paste Image 插件可实现访问裁切板 通过<code>Ctrl</code>+<code>Alt</code>+<code>C</code>自动将剪切板图片复制到文件当前目录下,但是这样页仅仅是满足了markdown格式,我们需要其能放在同名文件夹下</p><h2 id="局部设置"><a href="#局部设置" class="headerlink" title="局部设置"></a>局部设置</h2><p>若只想在当前文件夹下的.md文件中对Paste Image进行相关设置，可以在当前目录下的.vscode文件夹内创建settings.json文件，局部设置的优先级高于全局设置。如下所示进行设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;pasteImage.path&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;currentFileDir&#125;</span>/<span class="hljs-variable">$&#123;currentFileNameWithoutExt&#125;</span>&quot;</span>,<br>    <br>    <span class="hljs-string">&quot;pasteImage.insertPattern&quot;</span>: <span class="hljs-string">&quot;![](<span class="hljs-variable">$&#123;imageFileName&#125;</span>)&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><p>在首选项配置文件中找到settings.json进行同样操作,在次不再赘述</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>vscode上预览markdown时图片由于路径问题无法正确显示<br>若你已经有其他用markdown写笔记的需求 建议你只进行局部设置</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试加密模块</title>
    <link href="/2023/04/13/dd/"/>
    <url>/2023/04/13/dd/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8a952086cf211ef563b2fe80003be8c8fb535e560b8ed6c9ec11590016baa4cc">55b2803ebc192d0c2b188487861950f53901f0f897de39ebc2d24461a4bf4b30d90fa41fe548bf9b6d945179f400d49944b2abdda8e863a6aca6c32718cbbb588a37f037304d0c303073a8c4996df041e21478be17ff9735c2cca1023b1a44af076ea20ff30182c5368bd14136800c1de5c3da5a400b490bfcc98113ff7eb4ef6b26d2fe87d391d709e2f87c67b87c83e432691a6b754d5757925abfd259e7efb03195b7ad94e961888854e872be763ddde467198979f4524b0ed4876a6ac1ecb5db9c4d9b7ee5e761a325661d1f28eaf517844357de3c2117d650321ecad1bf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里需要密码才能访问。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello world</title>
    <link href="/2023/04/13/hello-world/"/>
    <url>/2023/04/13/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><hr><p>本站基于<a href="https://hexo.io/zh-cn/">hexo</a>框架搭建</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
