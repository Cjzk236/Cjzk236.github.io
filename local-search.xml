<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tag文件与Tag标记</title>
    <link href="/2023/05/04/jsp-3/"/>
    <url>/2023/05/04/jsp-3/</url>
    
    <content type="html"><![CDATA[<p><font size=6><strong>目录</strong></font></p><ul><li><a href="#tag%E6%96%87%E4%BB%B6">tag文件</a><ul><li><a href="#tag%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84">tag文件的结构</a></li><li><a href="#tag%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E5%AD%98">tag文件的保存</a><ul><li><a href="#tag%E6%96%87%E4%BB%B6%E6%89%80%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%95">tag文件所在的目录</a></li><li><a href="#tag%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81">tag文件的编码</a></li></ul></li></ul></li><li><a href="#tag%E6%A0%87%E8%AE%B0">tag标记</a><ul><li><a href="#tag%E6%A0%87%E8%AE%B0%E4%B8%8Etag%E6%96%87%E4%BB%B6">tag标记与tag文件</a></li><li><a href="#tag%E6%A0%87%E8%AE%B0%E7%9A%84%E4%BD%BF%E7%94%A8">tag标记的使用</a></li><li><a href="#tag%E6%A0%87%E8%AE%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86">tag标记的运行原理</a></li></ul></li><li><a href="#tag%E6%96%87%E4%BB%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4">tag文件的常用指令</a><ul><li><a href="#tag%E6%8C%87%E4%BB%A4">tag指令</a></li><li><a href="#include%E6%8C%87%E4%BB%A4">include指令</a></li><li><a href="#attribute%E6%8C%87%E4%BB%A4">attribute指令</a></li><li><a href="#variable%E6%8C%87%E4%BB%A4">variable指令</a></li><li><a href="#taglib%E6%8C%87%E4%BB%A4">taglib指令</a></li></ul></li></ul><h1 id="tag文件"><a href="#tag文件" class="headerlink" title="tag文件"></a>tag文件</h1><h2 id="tag文件的结构"><a href="#tag文件的结构" class="headerlink" title="tag文件的结构"></a>tag文件的结构</h2><p>Tag文件是扩展名为.tag的文本文件，其结构与jsp文件类似<br>包含:  </p><ul><li>HTML标记符</li><li>特殊的指令标记</li><li>成员变量和方法的定义</li><li>Java程序片和Java表达式</li></ul><h2 id="tag文件的保存"><a href="#tag文件的保存" class="headerlink" title="tag文件的保存"></a>tag文件的保存</h2><h3 id="tag文件所在的目录"><a href="#tag文件所在的目录" class="headerlink" title="tag文件所在的目录"></a>tag文件所在的目录</h3><p>建立目录结构</p><p><code>Web服务目录\WEB-INF\tags</code></p><ul><li>其中的WEB-INF（字母大写）和tags都是固定的目录名称，而tags下的子目录的名称可由用户给定。</li><li>一个Tag文件必须保存到tags目录或其下的子目录中。</li></ul><h3 id="tag文件的编码"><a href="#tag文件的编码" class="headerlink" title="tag文件的编码"></a>tag文件的编码</h3><p>Tag文件指定的编码是utf-8<br>通过在 JSP 标签文件的开始标记 <code>&lt;%@ tag %&gt;</code> 中添加 <code>charset</code> 属性。<br><code>&lt;%@ tag pageEncoding=&quot;utf-8&quot;%&gt;</code>  </p><h1 id="tag标记"><a href="#tag标记" class="headerlink" title="tag标记"></a>tag标记</h1><h2 id="tag标记与tag文件"><a href="#tag标记与tag文件" class="headerlink" title="tag标记与tag文件"></a>tag标记与tag文件</h2><p>Tag标记的名字和Tag文件的名字一致，也就是说，当我们编写了一个Tag文件并保存到特定目录中后,也就给出了一个Tag标记，tag格式为:<br><code>&lt;Tag文件的名字/&gt;</code><br>或者<br><code>&lt;Tag文件的名字&gt;其他内容（称为标体内容）&lt;/Tag文件的名字&gt;</code></p><ul><li>一个Tag文件对应一个Tag标记，把全体Tag标记称为一个自定义标记库或简称为标记库</li></ul><h2 id="tag标记的使用"><a href="#tag标记的使用" class="headerlink" title="tag标记的使用"></a>tag标记的使用</h2><p>一个jsp页面通过使用tag标记来调用一个Tag文件。Web服务目录下的一个jsp页面使用tag标记调用文件之前，必须首先使用taglib指令标记引入该web服务目录下的标记库，只有这样jsp才能调用相应的tag文件</p><p>taglib指令的格式如下:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@taglib</span> tagdir=<span class="hljs-string">&#x27;标记库的位置&#x27;</span> prefix=<span class="hljs-string">&#x27;前缀&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>例如:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<span class="hljs-meta">@taglib</span> tagdir=<span class="hljs-string">&#x27;/WEB-INF/tags&#x27;</span> prefix=<span class="hljs-string">&#x27;computer&#x27;</span>%&gt;<br></code></pre></td></tr></table></figure><ul><li>引入标记库后，JSP页面就可以使用带前缀的Tag标记调用相应的Tag文件，其中的前缀由<code>&lt;taglib&gt;</code>指令中的<code>prefix</code>属性指定。</li></ul><h2 id="tag标记的运行原理"><a href="#tag标记的运行原理" class="headerlink" title="tag标记的运行原理"></a>tag标记的运行原理</h2><ol><li>如果该Tag标记对应的Tag文件是首次被JSP页面调用，那么Tomcat服务器会将Tag文件转译成一个java文件，并编译这个java文件生成字节码文件，然后执行这个字节码文件（这和执行JSP页面的原理类似）。</li><li>如果该Tag文件已经被转编译为字节码文件，Tomcat服务器将直接执行这个字节码文件。</li><li>如果对Tag文件进行了修改，那么Tomcat服务器会重新将Tag文件转译成一个java文件，并编译这个java文件生成字节码文件，然后执行这个字节码文件。</li></ol><h1 id="tag文件的常用指令"><a href="#tag文件的常用指令" class="headerlink" title="tag文件的常用指令"></a>tag文件的常用指令</h1><h2 id="tag指令"><a href="#tag指令" class="headerlink" title="tag指令"></a>tag指令</h2><p>类似于JSP文件中的page指令。Tag文件通过使用tag指令可以指定某些属性的值<br>Tag指令的语法如下:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ tag 属性<span class="hljs-number">1</span>=<span class="hljs-string">&#x27;属性值&#x27;</span> 属性<span class="hljs-number">2</span>=<span class="hljs-string">&#x27;属性值&#x27;</span>---属性n=<span class="hljs-string">&#x27;属性值&#x27;</span>% &gt;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ tag 属性<span class="hljs-number">1</span>=<span class="hljs-string">&#x27;属性值&#x27;</span> % &gt;<br>&lt;%@ tag 属性<span class="hljs-number">2</span>=<span class="hljs-string">&#x27;属性值&#x27;</span> % &gt;<br>&lt;%@ tag 属性<span class="hljs-number">3</span>=<span class="hljs-string">&#x27;属性值&#x27;</span> % &gt;<br>······<br>&lt;%@ tag 属性n=<span class="hljs-string">&#x27;属性值&#x27;</span> % &gt;<br></code></pre></td></tr></table></figure><ul><li><p>language属性<br>只能取值<code>java</code>，其默认值就是<code>java</code>，没有必要使用tag指令指定language属性的值。</p></li><li><p>import属性<br>import属性的作用是为Tag文件引入包中的类import属性默认已经有如下值：<code>java.lang.*</code>、 <code>javax.servlet.*</code>、<code>javax.servlet.jsp.*</code>、<code>javax.servlet.http.*</code>。</p></li></ul><p>c.pageEncording<br>该属性指定Tag文件的字符编码，其默认值是<code>ISO-8859-1</code>。目前，为了避免显示信息出现乱码现象，Tag文件需要将该属性值设置为<code>utf-8</code>。</p><h2 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h2><p>Tag文件中也有和JSP文件类似的include指令标记，其使用方法和作用与JSP文件中的include指令标记类似。</p><h2 id="attribute指令"><a href="#attribute指令" class="headerlink" title="attribute指令"></a>attribute指令</h2><ul><li>在tag文件中通过attribute指令让使用它的jsp页面向该页面tag文件传递需要的数据。<br>方式如下：  <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ attribute name=<span class="hljs-string">&quot;对象名字&quot;</span> required=<span class="hljs-string">&quot;ture&quot;</span>|<span class="hljs-string">&quot;false&quot;</span> type =<span class="hljs-string">&quot;对象的类型&quot;</span>%&gt;<br></code></pre></td></tr></table></figure></li></ul><p>例如:<code>&lt;%@ attribute name=&quot;reuslt&quot; required=&quot;ture&quot; type=&quot;java.lang.Double&quot;%&gt;</code><br>相当于tag文件中有了一个名字是result的对象，但Tag文件不需要创建该对象result，<br>而是等待JSP页面将一个Double型的对象的引用传递给result。</p><ul><li>JSP页面使用Tag文件所调用的Tag文件中name指定的对象传递一个引用，方式如下：<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;前缀:Tag文件名字 对象名字=<span class="hljs-string">&quot;对象的引用&quot;</span>/&gt;<br></code></pre></td></tr></table></figure></li></ul><h2 id="variable指令"><a href="#variable指令" class="headerlink" title="variable指令"></a>variable指令</h2><p>Tag文件通过使用variable指令可以将Tag文件中的对象返回给调用该Tag文件的JSP页面，格式如下：  </p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ variable name-given=<span class="hljs-string">&quot;对象名&quot;</span> variable-class=<span class="hljs-string">&quot;对象类型&quot;</span> scope=<span class="hljs-string">&quot;有效范围&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ul><li><p>name-givenTag<br>返回给jsp页面的对象，由字母，数字，下画线和美元符号组成</p></li><li><p>variable-class<br>返回的对象的类型，必须要完整包名，默认为java.lang.String类型</p></li><li><p>scope<br>  可以取：AT_BEGIN、NESTED和AT_END。</p><ul><li>AT_BEGIN：一开始使用Tag标记，就得到了返回的对象</li><li>NESTED：只可以在Tag标记的标记体中使用返回的对象</li><li>AT_END：在Tag标记结束后，才能返回对象</li></ul></li></ul><h2 id="taglib指令"><a href="#taglib指令" class="headerlink" title="taglib指令"></a>taglib指令</h2><p>引入标记库，格式如下</p><pre><code class="jsp">&lt;%@ taglib tagdir=&quot;自定义标记库的位置&quot; prefix=&quot;前缀&quot;&gt;```jsp- JSP页面或Tag文件都可以使用taglib指令使用标记库————————————————</code></pre>]]></content>
    
    
    <categories>
      
      <category>JSP</category>
      
      <category>第三章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的遍历和线索二叉树</title>
    <link href="/2023/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><p>三种方式都比较简单 原理相同</p><h3 id="递归先序"><a href="#递归先序" class="headerlink" title="递归先序"></a>递归先序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_front</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!T)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,T-&gt;data);<br>    DisplayTree_front(T-&gt;lchild);<br>    DisplayTree_front(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归中序"><a href="#递归中序" class="headerlink" title="递归中序"></a>递归中序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_middle</span><span class="hljs-params">(Bitree T)</span>&#123;t<br>    <span class="hljs-title function_">if</span><span class="hljs-params">(!T)</span><br>        <span class="hljs-keyword">return</span>;<br>    DisplayTree_middle(T-&gt;lchild);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,T-&gt;data);<br>    DisplayTree_middle(T-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归后续"><a href="#递归后续" class="headerlink" title="递归后续"></a>递归后续</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_back</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!T)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    DisplayTree_back(T-&gt;lchild);<br>    DisplayTree_back(T-&gt;rchild);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,T-&gt;data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><p>非递归先序遍历与非递归中序遍历原理相同 且比较简单</p><h3 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_front_unrec</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    LinkStack s;<br>    InitLStack(&amp;s);<br>    BitreeNode *p=T;<br>    <span class="hljs-keyword">while</span>(p|| EmptyStack(s))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            PushStack(&amp;s,p);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,p-&gt;data);<br>            p=p-&gt;lchild;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            p= PopStack(&amp;s);<br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DisplayTree_In_unrec</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    LinkStack s;<br>    InitLStack(&amp;s);<br>    BitreeNode *p=T;<br>    <span class="hljs-keyword">while</span>(p|| EmptyStack(s))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            PushStack(&amp;s,p);<br>            p=p-&gt;lchild;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            p= PopStack(&amp;s);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,p-&gt;data);<br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非递归后续遍历"><a href="#非递归后续遍历" class="headerlink" title="非递归后续遍历"></a>非递归后续遍历</h3><p>与前两者不同，后续遍历中，要保证左孩子和右孩子都已被访问并且先访问左孩子后访问右孩子才能访问根节点。<br>算法思想：<br>    1. 从根节点开始，沿着左结点依次向下搜索，直到没有左结点的节点，全部按顺序依次入栈<br>    2. <strong>读取栈顶元素</strong>，判断其是否有右节点且是否被输出过，若有右结点且右结点没别访问过，则指针转向右结点，并执行 1 ；若没有右结点<strong>或者</strong>右节点已经被输出了，则出栈顶元素并输出该结点。<br>    3. 需要一个指针用于记录上一个输出的结点， 若一个结点的右孩子等于r，即该结点右节点已被输出，说明该结点所有子节点都被输出完了，该输出它自己了</p><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DispalyTree_back_unrec</span><span class="hljs-params">(Bitree T)</span>&#123;<br>    LinkStack s;<br>    InitLStack(&amp;s);<br>    BitreeNode *p=T;<br>    BitreeNode *r=<span class="hljs-literal">NULL</span>;                 <span class="hljs-comment">//用于指向上一个输出的节点</span><br>    <span class="hljs-keyword">while</span>(p|| EmptyStack(s))&#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;                          <span class="hljs-comment">//沿着左节点依次向下，全部入栈，直到为空</span><br>            PushStack(&amp;s,p);<br>            p=p-&gt;lchild;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            p=GetTop(s);                        <span class="hljs-comment">//读取栈顶元素</span><br>            <span class="hljs-keyword">if</span>(p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)         <span class="hljs-comment">//若栈顶元素右结点存在，且未被输出</span><br>                p=p-&gt;rchild;                    <span class="hljs-comment">//转向结点</span><br>            <span class="hljs-keyword">else</span>&#123;                               <span class="hljs-comment">//否则,出栈并输出</span><br>                p=PopStack(&amp;s);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\t&quot;</span>,p-&gt;data);<br>                r=p;                            <span class="hljs-comment">//用于记录最后一个被输出的结点</span><br>                p=<span class="hljs-literal">NULL</span>;                         <span class="hljs-comment">//p置空,进入下一次循环</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h1><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li><p>在二叉树的前序序列、中序序列和后序序列中，所有<strong>叶子结点</strong>的前后顺序完全相同</p></li><li><p><strong>线索二叉树是一种物理结构</strong></p><ul><li>二叉树是一种逻辑结构，而线索二叉树明确指明了在存储过程中的数据存放方式，就是物理结构了。（物理结构&#x3D;存储结构）</li><li>若即指明了存储结构，又指明了逻辑结构的情况就是单独的“物理结构”，所以说线索二叉树是一种逻辑和存储结构是错误的，没有这种说法</li></ul></li><li><p>在中序线索树中，若某结点有左孩子，则其前驱结点是它左子树的最右下结点；若某结点有右孩子，则其后继结点时它右子树的最左下结点。</p></li><li><p>线索二叉树找前驱后继问题</p></li></ul><table><thead><tr><th></th><th align="center">先序线索二叉树</th><th align="center">中序线索二叉树</th><th align="center">后续线索二叉树</th></tr></thead><tbody><tr><td>找前驱</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td>找后继</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr></tbody></table><p>除非用三叉链表，或者用土方法从根开始遍历</p><ul><li>后序线索树的遍历仍需要栈的支持</li></ul><p>二叉树线索化后，对于遍历我们仅需要关注非叶节点，在前序和中序的非叶节点中我们都能通过其孩子的指针找到其遍历后续，而后续的非叶节点不一定能确保能找到遍历后续</p><p><img src="/2023/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/2023-04-26-21-29-14.png"></p><ul><li><p>※前序遍历序列和后序遍历序列不能确定一棵树，但是能确定结点的父子关系<br>如：<br>  前序：根左右,相对顺序：根左，根右，左右<br>  后续：左右根,相对顺序：左根，右根，左右<br>可以得出：<br><font color="#0df2c9">两个结点，在前序和后续中的前后关系不同，证明二者是父子关系，如果相同，二者是兄弟关系</font></p><ul><li><strong>若遇到前中后序列相同相同问题，思路可以是分析其<code>相对顺序</code>来找出规律</strong></li></ul></li><li><p><strong>技巧</strong>：根据二叉树前序遍历和中序遍历的递归算法中递归工作栈的状态变化得出：  </p><ul><li><font color="#0df2c9">前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序</font></li><li><font color="#0df2c9">对于n个不同元素进栈，出栈序列的个数为 $\frac{1}{n+1} C_{2n}^{n} $</font></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>第五章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础-1-基础算法（二）</title>
    <link href="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><p>c++才需要<br>因为 Java 和 Python 是不需要高精度计算的，因为这两个语言直接支持高精度数据。</p><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p><a href="https://www.acwing.com/problem/content/793/">题目791.</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-22-13-03-04.png"><br>完整代码:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//C=A+B</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;      <span class="hljs-comment">//加引用是为了提高效率,不用copy一遍</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;      <span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>())  t+=A[i];<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())  t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t=t/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a,b;         <span class="hljs-comment">//用字符串读入</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;    <span class="hljs-comment">//存到vector里去</span><br>    cin &gt;&gt; a&gt;&gt; b;       <span class="hljs-comment">//正序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);  <span class="hljs-comment">//逆序//-&#x27;0&#x27;是因为a[i]中存的是字母 而我们需要存的是数字</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">add</span>(A,B);            <span class="hljs-comment">//auto就是编译器可以自己识别自己需要的类型并转变为它</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>大整数存储<ul><li>存入数组,低位在前,这样进位添加高位直接在数组后面插入即可</li></ul></li><li>模拟人工加法过程<ul><li>A<sub>i</sub>+B<sub>i</sub>+t(进位: 0 or 1)</li></ul></li></ul><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>函数使用引用或指针一般能使代码速度更快,占用空间更小</li><li>上面完整代码和代码模板思路是一样的 都可以写</li><li>auto就是编译器可以自己识别自己需要的类型并转变为它</li><li>用字符串读入数字后,要传入数组需要将其-‘0’</li></ul><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>题目:<a href="https://www.acwing.com/problem/content/794/">高进度减法</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-23-13-10-08.png"><br>完整代码:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//判断A&gt;=B</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>())   <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(A[i]!=B[i])  <span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//C=A-B</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<br>        t=A[i]-t;<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>())  t-=B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);              <span class="hljs-comment">//t&gt;=0 t;t&lt;0 t+10</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t=<span class="hljs-number">1</span>;                         <span class="hljs-comment">//判断是否借位</span><br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>)   C.<span class="hljs-built_in">pop_back</span>();   <span class="hljs-comment">//去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin &gt;&gt; a&gt;&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))&#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(B,A);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>大致与加法相同</li><li>判断<code>A≥B</code> 若 <code>ture</code> 则 直接算<code>A-B</code>, 若<code>false</code> 则算<code>-(B-A)</code></li><li>判断<code>A[i]-B[i]-t</code> ,若<code>≥0</code>,则<code>A[i]-B[i]-t</code>;若<code>&lt;0</code>,则<code>A[i]-B[i]+10-t</code></li><li>去掉前导<code>0</code></li></ol><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;                                <span class="hljs-comment">//判断是否借位</span><br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-comment">//去掉前导0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>不要忘记去掉前导零<ul><li>注意一位的时候无需去除 结果就是0</li></ul></li><li><code>(t+10)%10</code><ul><li><code>t&gt;=0</code> 结果为<code>t</code></li><li><code>t&lt;0</code>  结果为<code>t+10</code></li></ul></li><li>完整代码中的cmp函数写的很精简优美.</li></ul><h2 id="高精度乘以低精度"><a href="#高精度乘以低精度" class="headerlink" title="高精度乘以低精度"></a>高精度乘以低精度</h2><p>题目:<a href="https://www.acwing.com/problem/content/795/">高精度乘法</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-23-19-00-53.png"><br>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mult</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||t;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i]*b;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t=t/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>&amp;&amp;C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)    C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">mult</span>(A,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><ol><li>用大数的每一位 分别乘以小数 再加上进位即可</li><li>去先导0</li></ol><h3 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h2><p><a href="https://www.acwing.com/problem/content/796/">高精度除法</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-23-21-47-56.png"><br>完整代码  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//A/B 商是C，余数是r</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> &amp;b,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;         <span class="hljs-comment">//是逆着存 A[0]存的低位</span><br>        r=A[i]+r*<span class="hljs-number">10</span>;<br>        C.<span class="hljs-built_in">push_back</span>(r/b);                   <span class="hljs-comment">//C顺着存  C[0]存的高位</span><br>        r=r%b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">//反转，使C逆着存 C[0]是低位</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>&amp;&amp;C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)    C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">div</span>(A,b,r);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-----%d------&quot;</span>,A.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><h3 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>除法不同于加减乘，是由高位开始运算的，得出的结果也是高位在前,一般来说正着运算会好一点，但题目一般加减乘除一起出现，所以统一倒着来存</li><li>需要颠倒使得高位在后 可以比较方便的去先导零</li></ul><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="前缀和-1"><a href="#前缀和-1" class="headerlink" title="前缀和"></a>前缀和</h2><p><a href="https://www.acwing.com/problem/content/797/">题目</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-24-17-30-14.png"><br>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],s[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);    <span class="hljs-comment">//前缀和的初始化</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="hljs-number">-1</span>]+a[i];    <span class="hljs-comment">//可与上一条循环语句一起写</span><br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="hljs-number">-1</span>]);             <span class="hljs-comment">//区间和的计算</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码模板-4"><a href="#代码模板-4" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]                <span class="hljs-comment">//初始化,即预处理</span><br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]          <span class="hljs-comment">//计算,即询问</span><br></code></pre></td></tr></table></figure><p>作用:   求某段区间的和</p><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意:"></a>注意:</h3><ul><li>预处理  O(n)</li><li>询问    O(1)</li><li>下标从1开始 避免了边界问题</li></ul><h2 id="子矩阵的和"><a href="#子矩阵的和" class="headerlink" title="子矩阵的和"></a>子矩阵的和</h2><p><a href="https://www.acwing.com/problem/content/798/">题目</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-24-18-09-57.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,m,q,a[N][N],s[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]),s[i][j]=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j];<span class="hljs-comment">//初始化，并求前缀和</span><br>    <br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="hljs-number">-1</span>]-s[x1<span class="hljs-number">-1</span>][y2]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<span class="hljs-comment">//算子矩阵部分和</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码模板-5"><a href="#代码模板-5" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i, j] = 第i行j列格子左上部分所有元素的和 <br>    即s[i][j]=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j]<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br>    即s[x2][y2]-s[x2][y1<span class="hljs-number">-1</span>]-s[x1<span class="hljs-number">-1</span>][y2]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><h3 id="注意-4"><a href="#注意-4" class="headerlink" title="注意:"></a>注意:</h3><ul><li>下标从1开始</li></ul><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>本质是前缀和的逆运算</p><h2 id="差分-1"><a href="#差分-1" class="headerlink" title="差分"></a>差分</h2><p><a href="https://www.acwing.com/problem/content/799/">题目</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-24-20-53-34.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123; <span class="hljs-comment">//使得数组a在[l,r]区间上每个元素加上c</span><br>    b[l]+=c;<br>    b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]),<span class="hljs-built_in">insert</span>(i,i,a[i]); <span class="hljs-comment">//在构建数组a的同时 利用差分性质构建a的差分数组b</span><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   b[i]+=b[i<span class="hljs-number">-1</span>],<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i]);    <span class="hljs-comment">//数组b变成自己的前缀和,并输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>数组<code>a[1],a[2],a[3]...a[n]</code> ,构造<code>b[1],b[2],b[3]...b[n]</code> ,使得 <code>a[i]=b[1]+b[2]+...+b[i]</code>.此时<code>数组a</code>是<code>数组b</code>的<code>前缀和</code>  <code>数组b</code>是<code>数组a</code>的<code>差分</code></li><li>若<code>b[i]+c</code> 那么<code>a[i],a[i+1]....a[n]</code>都会加上<code>c</code>,若<code>b[i]-c</code> 那么<code>a[i],a[i+1]....a[n]</code>都会减上<code>c</code></li><li>由2可得 要使<code>数组a</code>的<code>[l,r]</code>区间内每个元素都加上<code>c</code>,可使<code>b[l]</code>加上<code>c</code>,<code>b[r+1]</code>减上<code>c</code></li><li>利用4 在构建<code>数组a</code> 的同时 构建<code>数组b</code></li></ol><h3 id="代码模板-6"><a href="#代码模板-6" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">给数组a区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><strong>※如何构造差分:利用 <code>数组a区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c</code> 的性质 可以在构建a数组的同时构建b数组 <em>设a b数组元素初始全为0</em>  若构建a数组时由0变为a[i]  根据特性此时b[i]+&#x3D;a[i] ,b[i+1]-&#x3D;c  ,数组a构建完成时,数组b也构建完成</strong></li><li>由数组b到数组a 时间复杂度需要O(n)</li><li>数组a [l,r] 中得每个数加上c 时间复杂度O(1)</li></ul><h2 id="差分矩阵"><a href="#差分矩阵" class="headerlink" title="差分矩阵"></a>差分矩阵</h2><p><a href="https://www.acwing.com/problem/content/800/">题目</a><br><img src="/2023/04/22/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/2023-04-24-21-12-17.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N][N],b[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    b[x1][y1]+=c;<br>    b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>    b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>    b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)   <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]),<span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);   <span class="hljs-comment">//构建矩阵a的同时，构建矩阵b</span><br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d %d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);                      <br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)  <br>            b[i][j]+=b[i<span class="hljs-number">-1</span>][j]+b[i][j<span class="hljs-number">-1</span>]-b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i][j]);<span class="hljs-comment">//将矩阵b变成自己的前缀和并输出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码模板-7"><a href="#代码模板-7" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br>即:使得矩阵a的以[x1,y1]为左上角,[x2,y2]为右下角的子矩阵中的所有元素加上c<br>    b[x1][y1]+=c;<br>    b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>    b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>    b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSP语法</title>
    <link href="/2023/04/19/jsp-2/"/>
    <url>/2023/04/19/jsp-2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-JSP页面的基本结构"><a href="#1-JSP页面的基本结构" class="headerlink" title="1 JSP页面的基本结构"></a>1 JSP页面的基本结构</h1><ul><li>普通的HTML标记和JavaScript标记</li><li>JSP标记，如指令标记、动作标记</li><li>变量和方法的声明</li><li>Java 程序片</li><li>Java 表达式</li></ul><h1 id="2-声明变量和定义方法"><a href="#2-声明变量和定义方法" class="headerlink" title="2 声明变量和定义方法"></a>2 声明变量和定义方法</h1><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>格式:<code>&lt;%!变量%&gt;</code>  </p><ul><li>声明的变量在整个JSP页面内都有效</li></ul><h2 id="定于方法"><a href="#定于方法" class="headerlink" title="定于方法"></a>定于方法</h2><p>格式:<code>&lt;%!方法or类%&gt;</code>  </p><ul><li>可以在Java程序片中调用该方法或使用该类创造对象</li></ul><h1 id="3-Java程序片"><a href="#3-Java程序片" class="headerlink" title="3 Java程序片"></a>3 Java程序片</h1><p>格式:<code>&lt;%所插入的java程序片%&gt;</code></p><ul><li>在程序片中声明的变量称作JSP页面的局部变量。局部变量的有效范围与其声明的位置有关，即局部变量在JSP页面后继的所有程序片以及表达式部分内都有效。</li></ul><h1 id="4-Java表达式"><a href="#4-Java表达式" class="headerlink" title="4 Java表达式"></a>4 Java表达式</h1><p>格式:<code>&lt;%=可求值得表达式%&gt;</code></p><ul><li>注意:<code>&lt;%</code>和<code>=</code>之间不能有空格</li></ul><h1 id="5-JSP中的注释"><a href="#5-JSP中的注释" class="headerlink" title="5 JSP中的注释"></a>5 JSP中的注释</h1><h2 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h2><p>格式:<code>&lt;!-----注释内容------&gt;</code></p><ul><li>JSP会把HTML注释交给用户,因此用户可在查看页面源码时看到HTML注释</li></ul><h2 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h2><p>格式:<code>&lt;% ----注释内容----%&gt;</code></p><ul><li>在编译JSP页面时会忽略JSP注释</li></ul><h1 id="6-JSP指令标记"><a href="#6-JSP指令标记" class="headerlink" title="6 JSP指令标记"></a>6 JSP指令标记</h1><h2 id="page指令标记"><a href="#page指令标记" class="headerlink" title="page指令标记"></a>page指令标记</h2><p>page 指令用来定义整个JSP页面的一些属性和这些属性的值。<br>可以使用多个page指令分别为每个属性指定值:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;%@ page   属性<span class="hljs-number">1</span>=<span class="hljs-string">&quot;属性1的值&quot;</span>  %&gt;<br>&lt;%@ page   属性<span class="hljs-number">2</span>=<span class="hljs-string">&quot;属性2的值&quot;</span>  %&gt;<br>… …<br>&lt;%@ page   属性n=<span class="hljs-string">&quot;属性n的值&quot;</span>  %&gt;<br></code></pre></td></tr></table></figure><p>也可以用一个page指令指定多个属性的值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;%@ page 属性<span class="hljs-number">1</span>=<span class="hljs-string">&quot;属性1的值&quot;</span> 属性<span class="hljs-number">2</span>=<span class="hljs-string">&quot;属性2的值&quot;</span> ...%&gt;<br></code></pre></td></tr></table></figure><h3 id="page指令标记可以指定的属性"><a href="#page指令标记可以指定的属性" class="headerlink" title="page指令标记可以指定的属性"></a>page指令标记可以指定的属性</h3><h4 id="contentType属性"><a href="#contentType属性" class="headerlink" title="contentType属性"></a>contentType属性</h4><p>contentType属性值确定JSP页面响应的MIME类型。属性值的一般形式是： “MIME类型”<br>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html &quot;</span> %&gt;<br></code></pre></td></tr></table></figure><ul><li>page指令只能为contentType指定一个值，不允许两次使用page指令给contentType属性指定不同的属性值。</li></ul><h4 id="pageEncoding-属性"><a href="#pageEncoding-属性" class="headerlink" title="pageEncoding 属性"></a>pageEncoding 属性</h4><p>用于保存JSP页面编码<br>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;%@ page pageEncoding = <span class="hljs-string">&quot;utf-8&quot;</span> %&gt;    <br></code></pre></td></tr></table></figure><ul><li>只能为pageEncoding指定一个值，不允许两次使用page指令给pageEncoding属性指定不同的或相同的属性值。</li></ul><h4 id="language属性"><a href="#language属性" class="headerlink" title="language属性"></a>language属性</h4><p>language属性定义JSP页面使用的脚本语言，该属性的值目前只能取”java”</p><ul><li>未指定,默认java</li></ul><h4 id="import-属性"><a href="#import-属性" class="headerlink" title="import 属性"></a>import 属性</h4><p>该属性的作用是为JSP页面引入Java运行环境提供的包中的类。<br>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;%@ page  <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.io.*&quot;</span>, <span class="hljs-string">&quot;java.time.LocalDate&quot;</span> %&gt;<br></code></pre></td></tr></table></figure><h4 id="session属性"><a href="#session属性" class="headerlink" title="session属性"></a>session属性</h4><p>session 属性用于设置是否需要使用内置的session对象。session的属性值可以是true或false。session属性默认的属性值是true</p><h4 id="buffer属性"><a href="#buffer属性" class="headerlink" title="buffer属性"></a>buffer属性</h4><p>内置输出流对象out负责将服务器的某些信息或运行结果发送到用户端显示。buffer属性用来指定out设置的缓冲区的大小或不使用缓冲区 </p><ul><li>默认时8kb<br>例如:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;%@ page buffer= <span class="hljs-string">&quot;24kb&quot;</span> %&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="autoFlush属性"><a href="#autoFlush属性" class="headerlink" title="autoFlush属性"></a>autoFlush属性</h4><p>autoFlush属性指定out的缓冲区被填满时，缓冲区是否会自动刷新。</p><ul><li>默认是true</li></ul><h4 id="isThreadSafe属性"><a href="#isThreadSafe属性" class="headerlink" title="isThreadSafe属性"></a>isThreadSafe属性</h4><p>isThreadSafe属性用来设置访问JSP页面是否是线程安全的</p><ul><li>默认是true 指CPU的使用权在各个线程间快速切换</li><li>可设置为false 指该JSP页面同一时刻只能响应一个用户的请求，其他用户须排队等待</li></ul><h4 id="info-属性"><a href="#info-属性" class="headerlink" title="info 属性"></a>info 属性</h4><p>info属性的属性值是一个字符串，其目的时为JSP页面准备一个常用但可能要经常修改的字符串。</p><h2 id="include指令标记"><a href="#include指令标记" class="headerlink" title="include指令标记"></a>include指令标记</h2><p>include可以在JSP页面内某处静态整体嵌入一个文件,该文件的编码必须和当前JSP页面一致</p><h1 id="7-JSP动作标记"><a href="#7-JSP动作标记" class="headerlink" title="7 JSP动作标记"></a>7 JSP动作标记</h1><p>动作标记时一种特殊的标记，它影响JSP运行时的功能。</p><h2 id="include动作标记"><a href="#include动作标记" class="headerlink" title="include动作标记"></a>include动作标记</h2><p>格式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-attr">jsp</span>:include page= <span class="hljs-string">&quot;文件的URL&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-attr">jsp</span>:include page= <span class="hljs-string">&quot;文件的URL&quot;</span> &gt;<br>   param子标记<br>&lt;/<span class="hljs-attr">jsp</span>:include&gt;<br></code></pre></td></tr></table></figure><h2 id="param动作标记"><a href="#param动作标记" class="headerlink" title="param动作标记"></a>param动作标记</h2><p>param标记以<code>名字—值</code>对的形式为其他标记提供附加信息。<br>格式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-attr">jsp</span>:param  name= <span class="hljs-string">&quot;参数&quot;</span>  value= <span class="hljs-string">&quot; 参数的值&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h2 id="forward-动作标记"><a href="#forward-动作标记" class="headerlink" title="forward 动作标记"></a>forward 动作标记</h2><p>作用是从该指令处停止当前页面的执行，而转向执行page属性指定的JSP页面。<br>格式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-attr">jsp</span>:forward page=<span class="hljs-string">&quot;要转向的页面&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;<span class="hljs-attr">jsp</span>:forward page=<span class="hljs-string">&quot;要转向的页面&quot;</span> &gt;<br>   param子标记<br>&lt;/<span class="hljs-attr">jsp</span>:forward&gt;<br></code></pre></td></tr></table></figure><ul><li>浏览器地址栏中显示的仍然是转向前的JSP页面的URL地址</li></ul><h2 id="useBean动作标记"><a href="#useBean动作标记" class="headerlink" title="useBean动作标记"></a>useBean动作标记</h2><p>useBean标记时用来创建并使用一个JavaBean，见后续章节</p>]]></content>
    
    
    <categories>
      
      <category>JSP</category>
      
      <category>第二章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法基础-1-基础算法（一）</title>
    <link href="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>题目:<br><a href="https://www.acwing.com/problem/content/787/">快速排序</a><br><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-04-23-13-08-12.png"><br>完整代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-comment">//加10防止越界</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j),<span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>分治</strong></p><ol><li>确定分界点：头 、尾 、（头＋尾）&#x2F;2、 随机</li><li>调整区间，使得小于分界点的数全在其左边，大于分界点的数全在右边<ul><li>利用两个指针在数列两头向中间移动，左边的指针在碰到大于等于分界点时停下，右边的指针反之，都停下时交换两数，循环上述过程，直到两指针相交</li></ul></li><li>递归处理左右两端</li></ol><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a><strong>代码模板</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">//区间元素一个或者没有</span><br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p><strong>若x取q[l]或者q[r]要考虑边界问题</strong><br>若 递归处用 i-1 和 i ,则x<strong>不可以</strong>取q[l] ,<strong>可以</strong>取q[r]或者q[(l+r+1)&#x2F;2]或者q[l+r+1&gt;&gt;1]等<br>若 递归处用 j 和 j+1 ,则x<strong>不可以</strong>取q[r] ,<strong>可以</strong>取q[l]或者q[(l+r)&#x2F;2]或者q[l+r&gt;&gt;1]等<br>否则可能会出现死循环<br>例如:x取q[l],递归处用i-1和i,排序12,会无限调用递归quick_sort(q,0,1),即无限划分<br>具体见<code>分析</code></p></li><li><p><strong>快排是不稳定的</strong><br>在排序前，关键字值相等的不同记录，排序后相对位置保持不变的排序方法，称为稳定排序方法（但其实没软用）<br>如何把快排变成稳定的呢—————把快排每个数变成不同的，可把每个数据弄成二元组，双关键字排序</p></li><li><p>c++的sort是快排和插入的组合,小范围用插入,大范围用快排</p></li><li><p>scanf比cin快<br><code>ios::sync_with_stdio(false); </code>可以让cin变快，但是副作用是不能用scanf了</p></li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h3><ul><li><strong>边界问题分析</strong><br>分治算法最怕<code>n分成0和n,或n分成n和0</code>,这会造成<em>无限划分</em><br>若<code>x=q[l]</code>时 最极端情况是<code>i=l,j=l</code> 此时若划分为<code>(l,i-1)</code>和<code>(i,r)</code> 其中<code>(i,r)</code>划分的就是<code>n</code> 这就出现了<em>无限划分</em><br>若<code>x=q[r]</code>时 最极端情况时<code>i=r,j=r</code> 此时若划分为<code>(l,j)</code>和<code>(j+1,r)</code> 其中<code>(l,j)</code>划分的就是<code>n</code> 这就出现了<em>无限划分</em></li><li>关于<code>q[l+r&gt;&gt;1]</code>和<code>q[l+r+1&gt;&gt;1]</code> 的问题,<br><code>q[l+r+1&gt;&gt;1]</code>是向上取整,因为向上取整时有可能取到q[r],为了避免<em>无限划分</em>,所以递归处划分应该是i-1和i<br><code>q[l+r&gt;&gt;1]</code>是向下取整,因为向下取整时有可能取到q[l],为了避免<em>无限划分</em>,所以递归处划分应该时j和j+1<br><a href="https://www.acwing.com/solution/content/16777/"></a></li></ul><p>最后<br>为什么y总要<code>const int N = 1e6+10;</code> 要加10呢 我也没懂 但参考:<a href="https://www.zhihu.com/question/35047872">知乎</a></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>题目：<br><a href="https://www.acwing.com/problem/content/789/">归并排序</a><br><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-04-23-13-08-41.png"><br>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],temp[N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;            <br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">MergeSort</span>(q,l,mid),<span class="hljs-built_in">MergeSort</span>(q,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)<br>        <span class="hljs-keyword">if</span>(q[i]&lt;=q[j]) temp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> temp[k++]=q[j++];<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)   temp[k++]=q[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) temp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(i =l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++)  q[i]=temp[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-built_in">MergeSort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>分治</p><ol><li>确定分界点：mid&#x3D;l+r&gt;&gt;1</li><li>递归排序left，right<ul><li>确保每个区间都已排好顺序</li></ul></li><li>归并————合二为一 （时间复杂度O(n)）<ul><li>归并的两个区间已通过递归排好顺序,后面只需逐一比较,放入小的数即可</li></ul></li></ol><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;                                <span class="hljs-comment">//区间内元素一个或者没有</span><br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        <span class="hljs-comment">//q[i]=q[j]先存入q[i] 使之稳定</span><br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];       <span class="hljs-comment">//注意此处i从l开始到r j也可以用k 但要记得++</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>时间复杂度 nlogn</li></ul><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>题目:<br><a href="https://www.acwing.com/problem/content/791/">数的范围</a><br><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-04-23-13-09-07.png"><br>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <span class="hljs-comment">//确定左边界</span><br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;                     <span class="hljs-comment">//结束是l=r</span><br>            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;             <span class="hljs-comment">//mid是需要不断更新的值 放在循环内 </span><br>            <span class="hljs-keyword">if</span>(q[mid]&gt;=x)r=mid;         <span class="hljs-comment">//因为左边界右侧的数字都&gt;=x</span><br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(q[l]!=x)cout&lt;&lt;<span class="hljs-string">&quot;-1 -1&quot;</span>&lt;&lt;endl; <span class="hljs-comment">//无解</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;l&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;               <span class="hljs-comment">//输出左边界 l=r 所以输出r也可以</span><br>            <span class="hljs-comment">//确定右边界</span><br>            <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid]&lt;=x) l=mid;    <span class="hljs-comment">//右边界左边的数都&lt;=x</span><br>                <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            cout &lt;&lt; l &lt;&lt;endl;           <span class="hljs-comment">//输出右边界</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>二分的本质并不是单调性 有单调性一定可以二分 用二分的不一定有单调性<br>二分的本质是找<code>边界点</code> 每次二分时选择<strong>答案所在区间</strong> 当区间长度为1时 得出答案<br>若有某种性质使得一部分满足 另一部分不满足,二分可以用来寻找这个性质边界(两个边界对应两个模板)</p><h3 id="代码模板-2"><a href="#代码模板-2" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><span class="hljs-comment">//右边成立 二分右边的分界点</span><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">//左边成立 二分左边的分界点</span><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;       <span class="hljs-comment">//向上取整</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>写法</strong></p><ol><li>先写一个mid(不确定向上or向下取整)</li><li>想一个check函数</li><li>根据check函数想如何划分再确定mid向上取整还是向下取整</li></ol><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul><li>若模板二不能使用mid&#x3D;l+r&gt;&gt;1 即向下取整 此时如若l&#x3D;r-1 mid&#x3D;l 若check(mid)为true l&#x3D;mid&#x3D;l 进入死循环</li><li>二分是一定有解的(定义的性质一定有<code>边界</code>) 题目可能无解(根据二分出来的<code>边界</code>来判断有无解)</li><li>mid是需要不断更新的值 放在循环内</li></ul><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li><p><strong>边界问题</strong>:<br>关键在于缩小边界时l和r的取值是否会造成无限循环<br>如当<code>mid=l+r&gt;&gt;1</code>时 <code>mid</code>为向下取整 这时就有可能使得<code>mid=l</code> 而在缩小边界时,若使得<code>l=mid</code>,这无疑会产生无限循环,为此我们应该使得<code>mid</code>向上取整,即<code>mid=l+r+1&gt;&gt;1</code><br>同理有缩小边界使得<code>r=mid</code>,为了不让<code>mid</code>有可能取到<code>r</code>产生无限循环问题,应该使得<code>mid</code>向下取整,即<code>mid=l+r&gt;&gt;1</code><br>总结为:先不要确定mid向上取整还是向下取整,而是根据check函数来考虑缩小边界时是会使得<code>l</code>or<code>r</code>&#x3D;<code>mid</code><br>若<code>l=mid</code>,为了<strong>避免</strong><code>mid=l</code>的可能,我们使得<code>mid</code>向上取整,即<code>mid=l+r+1&gt;&gt;1</code><br>若<code>r=mid</code>,为了<strong>避免</strong><code>mid=r</code>的可能,我们使得<code>mid</code>向下取整,即<code>mid=l+r&gt;&gt;1</code><br><a href="https://www.acwing.com/solution/content/16798/"></a></p></li><li><p>if(check)中直接等于mid而else中+1-1问题<br>其实这要取决于我们所设置的check如例题中我们设置的是<code>q[mid]&gt;=x</code>条件,<br>若为<code>true</code>,那自然<code>mid</code>是满足条件的,所以边界<code>r</code>可以等于<code>mid</code><br>若为<code>false</code>,那自然<code>mid</code>是不满足条件的,所以边界<code>l</code>无疑不需要包含<code>mid</code><br><code>q[mid]&lt;=x</code>同理.</p></li></ul><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>浮点数二分因为没有<code>整除</code> 所以每次二分都能严格取一半 所以没有<code>边界问题</code> 所以很简单<br><a href="https://www.acwing.com/problem/content/792/">数的三次方根</a><br><img src="/2023/04/17/acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/2023-04-23-13-09-33.png"><br>题目有坑(2个)<br>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> esp = <span class="hljs-number">1e-8</span>;<br><span class="hljs-type">double</span> n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;n);<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">0</span>,r=n;<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(l,r);                     <span class="hljs-comment">//要考虑数为负数的情况 答案在[n,0]之间</span><br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">1</span>&amp;&amp;n&gt;<span class="hljs-number">-1</span>)&#123;                         <span class="hljs-comment">//还要特殊考虑-1&lt;n&lt;1的情况 因为绝对值小于1时,区间[l,r]根本不包含答案</span><br>        l=<span class="hljs-number">-1</span>;<br>        r=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(r-l&gt;esp)&#123;<br>        <span class="hljs-type">double</span> mid = (l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid*mid&gt;=n)  r=mid;<br>        <span class="hljs-keyword">else</span>                l=mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,r);                        <span class="hljs-comment">//l or r 都可</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>每次二分答案都在区间内部 当区间很小时 就得出答案</p><h3 id="代码模板-3"><a href="#代码模板-3" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;           <br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul><li>经验: 若题目要求保留n位小数 精度写1e-(n+2)</li><li>还有第二种写法 <ul><li>不用精度取迭代 而是直接循环100次 将<code>while (r - l &gt; eps)</code> 换成<code>for(int i=0;i&lt;100;i++)</code></li></ul></li><li>注意例题求数三次方根的两个坑<ul><li>考虑负数————交换l和r即可</li><li>考虑<code>-1&lt;n&lt;1</code>的情况,区间不包含答案————将区间设为[-1,1]即可</li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>算法基础</category>
      
      <category>第一章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OS-5-1-I/O管理概述</title>
    <link href="/2023/04/16/OS-5-1-I-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/04/16/OS-5-1-I-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="94060cc29a25a6ae2d60cb0f113d7e64af161d3ac566f92ce1303476b7bab2f5">01d7cac278ef89b863b3c951eb8364ec4b25d326537b8cfd6c2b318ff2e7cfa758872eb047d069c0cf34aa459c9db87c6c72f86f81990875b47621bfd65b0d5d77689312dbb393e7163366c91bb7f08d114855cc10b619cb9136db1257c70a0c99ca2374520f5e22e8e7143a7f1c69e9a30286b42e38723dc30dc3587df00a67123c9df8c9baae833a27b753ddc4b21d52b3f69fd7c7559a4d06b6174a4cc0700cce844da0b046c0b79862ffad9e8bdbfabe584a006bdc828613970c05d74c6d9cbb33216423a30b380fe9fd0afe92c77470f723bea25f929ece3efe459727acd706f99b3d91449e96097fa59b78b2b143fbb64ff1d53e016dfb54d9df632947eddecf26d19e84d33b1b25c308fe9cdff172da9793c953440c779ecaab1818117de77533ebed35a5507aabd2b2681ef7d17ac183aa03b2945df01965af45df05</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里需要密码才能访问。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>第五章</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pictest</title>
    <link href="/2023/04/15/pictest/"/>
    <url>/2023/04/15/pictest/</url>
    
    <content type="html"><![CDATA[<p>hexo如何更好的插入本地图片</p><hr><h1 id="全局资源文件夹"><a href="#全局资源文件夹" class="headerlink" title="全局资源文件夹"></a>全局资源文件夹</h1><p>hexo 全局资源文件夹<code>source/images</code>的图片可以直接用 markdown 语法 <code>![](image/someimage.jpg)</code>来引用,但图片放多了难以整理</p><h1 id="文章资源文件夹"><a href="#文章资源文件夹" class="headerlink" title="文章资源文件夹"></a>文章资源文件夹</h1><p>为了更有效的管理图片等资源可开启Hexo文章资源文件夹,可在<code>_config.yml</code>站点配置文件(注意是Hexo博客目录下,并非<code>theme/sometheme/_config.ml</code>)中进行修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>开启之后 每次 <code>hexo new [layout] &lt;title&gt;</code> 创建新文章时自动创建一个新同名文件夹 文件夹中的文件可直接用相对路径引用它们</p><h1 id="使用markdown嵌入图片"><a href="#使用markdown嵌入图片" class="headerlink" title="使用markdown嵌入图片"></a>使用markdown嵌入图片</h1><p>hexo-renderer-marked 3.1.0 引入了一个新的选项，其允许你无需使用 asset_img 标签插件就可以在 markdown 中嵌入图片</p><p>如需启用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">_config.yml</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>启用后，资源图片将会被自动解析为其对应文章的路径。<br>例如： <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code> ，这表示它是 <code>/2020/01/02/foo/</code> 文章的一张资源图片， <code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code> 。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>但是我们每次插入图片要放入相应文件夹很麻烦,为此我们在vscode 安装 Paste Image 插件可实现访问裁切板 通过<code>Ctrl</code>+<code>Alt</code>+<code>C</code>自动将剪切板图片复制到文件当前目录下,但是这样页仅仅是满足了markdown格式,我们需要其能放在同名文件夹下</p><h2 id="局部设置"><a href="#局部设置" class="headerlink" title="局部设置"></a>局部设置</h2><p>若只想在当前文件夹下的.md文件中对Paste Image进行相关设置，可以在当前目录下的.vscode文件夹内创建settings.json文件，局部设置的优先级高于全局设置。如下所示进行设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;pasteImage.path&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;currentFileDir&#125;</span>/<span class="hljs-variable">$&#123;currentFileNameWithoutExt&#125;</span>&quot;</span>,<br>    <br>    <span class="hljs-string">&quot;pasteImage.insertPattern&quot;</span>: <span class="hljs-string">&quot;![](<span class="hljs-variable">$&#123;imageFileName&#125;</span>)&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h2><p>在首选项配置文件中找到settings.json进行同样操作,在次不再赘述</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>vscode上预览markdown时图片由于路径问题无法正确显示<br>若你已经有其他用markdown写笔记的需求 建议你只进行局部设置</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试加密模块</title>
    <link href="/2023/04/13/dd/"/>
    <url>/2023/04/13/dd/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8a952086cf211ef563b2fe80003be8c8fb535e560b8ed6c9ec11590016baa4cc">55b2803ebc192d0c2b188487861950f53901f0f897de39ebc2d24461a4bf4b30d90fa41fe548bf9b6d945179f400d49944b2abdda8e863a6aca6c32718cbbb588a37f037304d0c303073a8c4996df041e21478be17ff9735c2cca1023b1a44af076ea20ff30182c5368bd14136800c1de5c3da5a400b490bfcc98113ff7eb4ef6b26d2fe87d391d709e2f87c67b87c83e432691a6b754d5757925abfd259e7efb03195b7ad94e961888854e872be763ddde467198979f4524b0ed4876a6ac1ecb5db9c4d9b7ee5e761a325661d1f28eaf517844357de3c2117d650321ecad1bf</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里需要密码才能访问。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello world</title>
    <link href="/2023/04/13/hello-world/"/>
    <url>/2023/04/13/hello-world/</url>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><hr><p>本站基于<a href="https://hexo.io/zh-cn/">hexo</a>框架搭建</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
